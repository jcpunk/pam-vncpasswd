/**
 * test_pam_fnal_vncpasswd.c - Tests for PAM module core functions
 *
 * Tests the functions in pam_fnal_vncpasswd.c that do not depend on PAM
 * headers: get_encrypt_settings(), generate_salt(), hash_password(),
 * verify_password(), validate_passwd_file(), authenticate_vnc_user(),
 * parse_pam_args(), ensure_dir().
 *
 * Uses the syscall_ops mock pattern: copy syscall_ops_default, override
 * specific fields per test.
 *
 * PASSWORD LENGTH POLICY:
 * The PAM module (authenticate_vnc_user) imposes NO password length limit.
 * A password longer than MAX_PASSWORD_LENGTH is simply treated as a wrong
 * password — crypt_r produces a different hash, verify_password returns -1,
 * and authenticate_vnc_user returns PAM_AUTH_ERR. This is tested explicitly
 * in pam_auth_password_too_long.
 *
 * YESCRYPT NOTES:
 * yescrypt is the default ENCRYPT_METHOD on modern RHEL/Fedora.
 * Its salt is generated by crypt_gensalt_ra("$y$", cost_factor, ...) where
 * cost_factor comes from YESCRYPT_COST_FACTOR in login.defs (default 5).
 * The resulting salt looks like "$y$j9T$<base64>$" (not "rounds=N$").
 */

#include "autoconf.h"
#include "pam_fnal_vncpasswd.h"
#include "syscall_ops.h"

#include <crypt.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "test_framework.h"

/*
 * Minimal PAM return code definitions for tests.
 * These must match the integer values in <security/pam_modules.h>.
 */
#ifndef PAM_SUCCESS
#define PAM_SUCCESS          0
#define PAM_AUTH_ERR         7
#define PAM_AUTHINFO_UNAVAIL 9
#define PAM_USER_UNKNOWN     10
#define PAM_AUTHTOK_ERR      20
#endif

/* ============================================================================
 * Mock Infrastructure
 * ============================================================================
 */

static char g_mock_fgets_content[4096];
static int g_mock_fgets_called;
static int g_mock_fstat_mode;
static uid_t g_mock_fstat_uid;
static int g_mock_fstat_type; /* 1=regular, 2=symlink, 3=other */
static int g_mock_mlock_called;
static int g_mock_munlock_called;
static uid_t g_mock_pw_uid;

/* fgets mock: returns lines from g_mock_fgets_content */
static char *mock_fgets(char *str, int n, FILE *stream) {
  (void)stream;
  static char *pos;
  if (!g_mock_fgets_called) {
    pos = g_mock_fgets_content;
    g_mock_fgets_called = 1;
  }
  if (!pos || *pos == '\0')
    return NULL;
  char *dst = str;
  int written = 0;
  while (*pos && written < n - 1) {
    *dst++ = *pos;
    written++;
    if (*pos++ == '\n')
      break;
  }
  *dst = '\0';
  return (written > 0) ? str : NULL;
}

static FILE *mock_fopen_ok(const char *p, const char *m) {
  (void)p; (void)m;
  return (FILE *)0x1;
}
static FILE *mock_fopen_fail(const char *p, const char *m) {
  (void)p; (void)m;
  errno = ENOENT;
  return NULL;
}
static FILE *mock_fdopen_ok(int fd, const char *m) {
  (void)fd; (void)m;
  return (FILE *)0x1; /* non-NULL sentinel; mock_fgets ignores the stream */
}
static FILE *mock_fdopen_fail(int fd, const char *m) {
  (void)fd; (void)m;
  errno = ENOMEM;
  return NULL;
}
static int mock_fclose_noop(FILE *f) { (void)f; return 0; }
static int mock_close_noop(int fd)   { (void)fd; return 0; }

static ssize_t mock_getrandom_ok(void *buf, size_t len, unsigned int flags) {
  (void)flags;
  memset(buf, 0x42, len);
  return (ssize_t)len;
}
static ssize_t mock_getrandom_fail(void *buf, size_t len, unsigned int flags) {
  (void)buf; (void)len; (void)flags;
  errno = EIO;
  return -1;
}

static char *mock_crypt_gensalt_ra_fail(const char *p, unsigned long c,
                                         const char *r, int n) {
  (void)p; (void)c; (void)r; (void)n;
  return NULL;
}

static char *mock_crypt_r_fail(const char *phrase, const char *setting,
                               struct crypt_data *data) {
  (void)phrase; (void)setting; (void)data;
  return NULL;
}

static int mock_open_fail(const char *p, int f, ...) {
  (void)p; (void)f;
  errno = ENOENT;
  return -1;
}

static int mock_fstat_ok(int fd, struct stat *st) {
  (void)fd;
  memset(st, 0, sizeof(*st));
  st->st_uid = g_mock_fstat_uid;
  if (g_mock_fstat_type == 2)
    st->st_mode = (mode_t)(S_IFLNK | 0600);
  else if (g_mock_fstat_type == 3)
    st->st_mode = (mode_t)(S_IFBLK | 0600);
  else
    st->st_mode = (mode_t)(S_IFREG | (g_mock_fstat_mode & 0777));
  return 0;
}
static int mock_fstat_fail(int fd, struct stat *st) {
  (void)fd; (void)st;
  errno = EIO;
  return -1;
}

static int mock_mlock_ok(const void *a, size_t l) {
  (void)a; (void)l;
  g_mock_mlock_called++;
  return 0;
}
static int mock_mlock_fail(const void *a, size_t l) {
  (void)a; (void)l;
  g_mock_mlock_called++;
  errno = EPERM;
  return -1;
}
static int mock_munlock_ok(const void *a, size_t l) {
  (void)a; (void)l;
  g_mock_munlock_called++;
  return 0;
}

static struct passwd g_mock_pw;
static int mock_getpwnam_r_ok(const char *name, struct passwd *pw,
                               char *buf, size_t buflen,
                               struct passwd **result) {
  (void)name; (void)buf; (void)buflen;
  *pw = g_mock_pw;
  *result = pw;
  return 0;
}
static int mock_getpwnam_r_fail(const char *name, struct passwd *pw,
                                 char *buf, size_t buflen,
                                 struct passwd **result) {
  (void)name; (void)pw; (void)buf; (void)buflen;
  *result = NULL;
  return ENOENT;
}
static int mock_getpwnam_r_notfound(const char *name, struct passwd *pw,
                                     char *buf, size_t buflen,
                                     struct passwd **result) {
  (void)name; (void)pw; (void)buf; (void)buflen;
  *result = NULL;
  return 0;
}

static void setup_fgets_mock(const char *content) {
  g_mock_fgets_called = 0;
  snprintf(g_mock_fgets_content, sizeof(g_mock_fgets_content), "%s", content);
}

/*
 * Mock read implementations.
 *
 * WHY THESE EXIST:
 * read_passwd_hash() now calls ops->read() instead of the bare read(2) syscall.
 * These mocks let tests exercise all code paths in read_passwd_hash() —
 * including error and empty-file paths — without needing a real file on disk.
 */
static const char *g_mock_read_data;  /* string to drip out byte-by-byte */
static size_t      g_mock_read_pos;   /* current position in g_mock_read_data */

static void setup_read_mock(const char *data) {
  g_mock_read_data = data;
  g_mock_read_pos  = 0;
}

/* Drip one byte at a time from g_mock_read_data, then return EOF. */
static ssize_t mock_read_data(int fd, void *buf, size_t count) {
  (void)fd; (void)count;
  if (!g_mock_read_data || g_mock_read_data[g_mock_read_pos] == '\0')
    return 0; /* EOF */
  *(char *)buf = g_mock_read_data[g_mock_read_pos++];
  return 1;
}

/* Always fail. */
static ssize_t mock_read_fail(int fd, void *buf, size_t count) {
  (void)fd; (void)buf; (void)count;
  errno = EIO;
  return -1;
}

/* ============================================================================
 * Test helpers
 * ============================================================================
 */

static void make_sha512_hash(const char *password, char *hash_out,
                             size_t hash_len) {
  struct crypt_data cd;
  memset(&cd, 0, sizeof(cd));
  char *h = crypt_r(password, "$6$rounds=65536$testsalt", &cd);
  if (h)
    snprintf(hash_out, hash_len, "%s", h);
}

static void make_yescrypt_hash(const char *password, char *hash_out,
                               size_t hash_len) {
  struct crypt_data cd;
  memset(&cd, 0, sizeof(cd));
  char rbytes[16];
  memset(rbytes, 0x77, sizeof(rbytes));
  char *salt = crypt_gensalt_ra("$y$", 5UL, rbytes, (int)sizeof(rbytes));
  if (!salt) return;
  char *h = crypt_r(password, salt, &cd);
  if (h)
    snprintf(hash_out, hash_len, "%s", h);
  free(salt);
}

/* ============================================================================
 * Tests: login.defs Parsing
 * ============================================================================
 */

TEST(get_encrypt_method_sha512) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD SHA512\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "SHA512", "Method should be SHA512");
}

TEST(get_encrypt_method_sha256) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD SHA256\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "SHA256", "Method should be SHA256");
}

/*
 * yescrypt is the default ENCRYPT_METHOD on modern RHEL/Fedora.
 * Verify both method and cost factor are parsed correctly.
 */
TEST(get_encrypt_method_yescrypt) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD YESCRYPT\nYESCRYPT_COST_FACTOR 11\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "YESCRYPT", "Method should be YESCRYPT");
  TEST_ASSERT_EQ((long)s.yescrypt_cost, 11L, "Yescrypt cost should be 11");
}

TEST(get_encrypt_method_blowfish) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD BLOWFISH\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "BLOWFISH", "Method should be BLOWFISH");
}

TEST(get_encrypt_method_missing) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("# no ENCRYPT_METHOD here\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, DEFAULT_ENCRYPT_METHOD,
                     "Should use default method");
}

TEST(get_encrypt_method_empty_value) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, DEFAULT_ENCRYPT_METHOD,
                     "Should fall back to default");
}

TEST(get_encrypt_method_file_not_found) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  ops.fopen = mock_fopen_fail;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Missing file should not be an error");
  TEST_ASSERT_STR_EQ(s.method, DEFAULT_ENCRYPT_METHOD,
                     "Should use default method");
}

TEST(get_encrypt_method_with_comments) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("# Comment\nENCRYPT_METHOD SHA512\n# Another\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "SHA512", "Method should be SHA512");
}

TEST(get_encrypt_method_with_leading_whitespace) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("  ENCRYPT_METHOD   SHA512\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "SHA512", "Method should be SHA512");
}

/* Key matching is case-sensitive per login.defs convention */
TEST(get_encrypt_method_case_insensitive_key) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("encrypt_method sha512\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, DEFAULT_ENCRYPT_METHOD,
                     "Lowercase key should not match");
}

TEST(get_encrypt_method_null_ops) {
  struct encrypt_settings s;
  TEST_ASSERT_EQ(get_encrypt_settings(NULL, "/etc/login.defs", &s), -1,
                 "NULL ops should return -1");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

/*
 * Verify yescrypt cost (YESCRYPT_COST_FACTOR) and SHA rounds
 * (SHA_CRYPT_MAX_ROUNDS) are parsed independently.
 */
TEST(get_yescrypt_cost_factor) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD YESCRYPT\n"
                   "YESCRYPT_COST_FACTOR 7\n"
                   "SHA_CRYPT_MAX_ROUNDS 100000\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_EQ((long)s.yescrypt_cost, 7L, "yescrypt cost should be 7");
  TEST_ASSERT_EQ((long)s.sha_rounds, 100000L, "SHA rounds should be 100000");
}

TEST(get_sha_crypt_rounds) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD SHA512\nSHA_CRYPT_MAX_ROUNDS 131072\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_EQ((long)s.sha_rounds, 131072L, "SHA rounds should be 131072");
}

/* ============================================================================
 * Tests: Salt Generation
 * ============================================================================
 */

TEST(generate_salt_sha512_prefix) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), 0, "Should succeed");
  TEST_ASSERT_EQ(strncmp(salt, "$6$", 3), 0, "Should start with $6$");
  TEST_ASSERT_NOT_EQ(strstr(salt, "rounds=65536"), NULL,
                     "Should contain rounds=65536");
}

TEST(generate_salt_sha256_prefix) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA256", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), 0, "Should succeed");
  TEST_ASSERT_EQ(strncmp(salt, "$5$", 3), 0, "Should start with $5$");
  TEST_ASSERT_NOT_EQ(strstr(salt, "rounds=65536"), NULL,
                     "Should contain rounds=65536");
}

/*
 * yescrypt salt does NOT contain "rounds=N" — cost is encoded differently
 * by crypt_gensalt_ra into a parameter string like "j9T".
 */
TEST(generate_salt_yescrypt_prefix) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "YESCRYPT", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), 0, "Should succeed");
  TEST_ASSERT_EQ(strncmp(salt, "$y$", 3), 0, "Should start with $y$");
  TEST_ASSERT_EQ(strstr(salt, "rounds="), NULL,
                 "yescrypt salt must not contain rounds= prefix");
}

/* Different yescrypt cost factors must produce different parameter strings */
TEST(generate_salt_yescrypt_cost_encoded) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  char salt5[SALT_BUF_SIZE], salt11[SALT_BUF_SIZE];
  struct encrypt_settings s5 = { "YESCRYPT", 65536UL, 5UL };
  struct encrypt_settings s11 = { "YESCRYPT", 65536UL, 11UL };
  TEST_ASSERT_EQ(generate_salt(&ops, &s5, salt5, sizeof(salt5)), 0, "cost=5");
  TEST_ASSERT_EQ(generate_salt(&ops, &s11, salt11, sizeof(salt11)), 0, "cost=11");
  TEST_ASSERT_EQ(strncmp(salt5, "$y$", 3), 0, "cost=5 starts with $y$");
  TEST_ASSERT_EQ(strncmp(salt11, "$y$", 3), 0, "cost=11 starts with $y$");
  TEST_ASSERT_STR_NOT_EQ(salt5, salt11, "Different costs must differ");
}

TEST(generate_salt_sufficient_length) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), 0, "Should succeed");
  TEST_ASSERT_NOT_EQ((long)strlen(salt), 0L, "Salt should not be empty");
}

TEST(generate_salt_getrandom_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_fail;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), -1,
                 "Should fail when getrandom fails");
}

TEST(generate_salt_null_buffer) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  TEST_ASSERT_EQ(generate_salt(&ops, &s, NULL, SALT_BUF_SIZE), -1,
                 "NULL buffer should fail");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

TEST(generate_salt_crypt_gensalt_ra_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  ops.crypt_gensalt_ra = mock_crypt_gensalt_ra_fail;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), -1,
                 "Should fail when crypt_gensalt_ra fails");
}

/* ============================================================================
 * Tests: Password Hashing and Verification
 * ============================================================================
 */

TEST(hash_password_sha512) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpass", &s, hash, sizeof(hash)), 0,
                 "Should succeed");
  TEST_ASSERT_EQ(strncmp(hash, "$6$", 3), 0, "Hash should use SHA-512");
}

TEST(hash_password_sha256) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA256", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpass", &s, hash, sizeof(hash)), 0,
                 "Should succeed");
  TEST_ASSERT_EQ(strncmp(hash, "$5$", 3), 0, "Hash should use SHA-256");
}

TEST(hash_password_yescrypt) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "YESCRYPT", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpass", &s, hash, sizeof(hash)), 0,
                 "yescrypt hash_password should succeed");
  TEST_ASSERT_EQ(strncmp(hash, "$y$", 3), 0, "yescrypt hash starts with $y$");
}

TEST(hash_password_null_password) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, NULL, &s, hash, sizeof(hash)), -1,
                 "NULL password should fail");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

TEST(hash_password_empty_password) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "", &s, hash, sizeof(hash)), -1,
                 "Empty password should fail");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

TEST(hash_password_crypt_r_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  ops.crypt_r = mock_crypt_r_fail;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpass", &s, hash, sizeof(hash)), -1,
                 "Should fail when crypt_r fails");
}

TEST(hash_password_getrandom_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_fail;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpass", &s, hash, sizeof(hash)), -1,
                 "Should fail when getrandom fails");
}

TEST(verify_password_correct) {
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("correct", hash, sizeof(hash));
  TEST_ASSERT_EQ(verify_password(&ops, "correct", hash), 0,
                 "Correct password should verify");
}

TEST(verify_password_incorrect) {
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("correct", hash, sizeof(hash));
  TEST_ASSERT_EQ(verify_password(&ops, "wrong", hash), -1,
                 "Wrong password should fail");
}

/* yescrypt full round-trip: hash then verify */
TEST(verify_password_yescrypt) {
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  make_yescrypt_hash("yescrypt1", hash, sizeof(hash));
  TEST_ASSERT_EQ(verify_password(&ops, "yescrypt1", hash), 0,
                 "Correct yescrypt password should verify");
  TEST_ASSERT_EQ(verify_password(&ops, "wrongpass", hash), -1,
                 "Wrong password should fail yescrypt verify");
}

TEST(verify_password_constant_time) {
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("secret", hash, sizeof(hash));
  TEST_ASSERT_EQ(verify_password(&ops, "secret", hash), 0, "Match");
  TEST_ASSERT_EQ(verify_password(&ops, "s", hash), -1, "Short no match");
  TEST_ASSERT_EQ(verify_password(&ops, "secretlonger", hash), -1,
                 "Long no match");
}

/*
 * Verify that verify_password() iterates to max(computed_len, stored_len)
 * rather than min(), closing the length-based timing side-channel.
 * The stored hash is produced from "aaa"; we test a completely wrong password
 * whose resulting hash is likely a different length (or same length, different
 * content) — both must return -1 without any shortcut.
 */
TEST(verify_password_different_lengths) {
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  /* Store hash for a valid 3-char password */
  make_sha512_hash("aaa", hash, sizeof(hash));
  /* Wrong password — must return -1 regardless of hash-length relationship */
  TEST_ASSERT_EQ(verify_password(&ops, "zzzzzzzz", hash), -1,
                 "Different password must not match");
  /* Empty-ish wrong — must also return -1 */
  TEST_ASSERT_EQ(verify_password(&ops, "a", hash), -1,
                 "Single-char wrong password must not match");
}

TEST(verify_password_null_inputs) {
  struct syscall_ops ops = syscall_ops_default;
  TEST_ASSERT_EQ(verify_password(&ops, NULL, "$6$salt$hash"), -1,
                 "NULL password should fail");
  TEST_ASSERT_EQ(verify_password(&ops, "pass", NULL), -1,
                 "NULL hash should fail");
}

TEST(verify_password_crypt_r_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.crypt_r = mock_crypt_r_fail;
  TEST_ASSERT_EQ(verify_password(&ops, "password", "$6$salt$hash"), -1,
                 "Should fail when crypt_r fails");
}

/* ============================================================================
 * Tests: Password File Validation
 * ============================================================================
 */

TEST(validate_passwd_file_good) {
  struct syscall_ops ops = syscall_ops_default;
  char tmpfile[] = "/tmp/test_fnal_vnc_passwd_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  fchmod(fd, 0600);
  close(fd);
  int result = validate_passwd_file(&ops, tmpfile, getuid());
  TEST_ASSERT_NOT_EQ(result, -1, "Good file should validate");
  if (result >= 0) close(result);
  unlink(tmpfile);
}

TEST(validate_passwd_file_world_readable) {
  struct syscall_ops ops = syscall_ops_default;
  char tmpfile[] = "/tmp/test_fnal_vnc_world_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  fchmod(fd, 0644);
  close(fd);
  TEST_ASSERT_EQ(validate_passwd_file(&ops, tmpfile, getuid()), -1,
                 "World-readable file should be rejected");
  unlink(tmpfile);
}

TEST(validate_passwd_file_group_readable) {
  struct syscall_ops ops = syscall_ops_default;
  char tmpfile[] = "/tmp/test_fnal_vnc_grp_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  fchmod(fd, 0640);
  close(fd);
  TEST_ASSERT_EQ(validate_passwd_file(&ops, tmpfile, getuid()), -1,
                 "Group-readable file should be rejected");
  unlink(tmpfile);
}

TEST(validate_passwd_file_wrong_owner) {
  struct syscall_ops ops = syscall_ops_default;
  g_mock_fstat_uid = 9999;
  g_mock_fstat_mode = 0600;
  g_mock_fstat_type = 1;
  ops.fstat = mock_fstat_ok;
  char tmpfile[] = "/tmp/test_fnal_vnc_owner_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  close(fd);
  TEST_ASSERT_EQ(validate_passwd_file(&ops, tmpfile, getuid()), -1,
                 "Wrong owner should be rejected");
  unlink(tmpfile);
}

TEST(validate_passwd_file_not_regular) {
  struct syscall_ops ops = syscall_ops_default;
  g_mock_fstat_uid = getuid();
  g_mock_fstat_mode = 0600;
  g_mock_fstat_type = 3;
  ops.fstat = mock_fstat_ok;
  char tmpfile[] = "/tmp/test_fnal_vnc_notreg_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  close(fd);
  TEST_ASSERT_EQ(validate_passwd_file(&ops, tmpfile, getuid()), -1,
                 "Non-regular file should be rejected");
  unlink(tmpfile);
}

TEST(validate_passwd_file_open_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_open_fail;
  TEST_ASSERT_EQ(validate_passwd_file(&ops, "/nonexistent", getuid()), -1,
                 "Should fail when open fails");
}

TEST(validate_passwd_file_fstat_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.fstat = mock_fstat_fail;
  char tmpfile[] = "/tmp/test_fnal_vnc_fstat_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  close(fd);
  TEST_ASSERT_EQ(validate_passwd_file(&ops, tmpfile, getuid()), -1,
                 "Should fail when fstat fails");
  unlink(tmpfile);
}

/* ============================================================================
 * Tests: read_passwd_hash (via ops->fdopen + ops->fgets mocks)
 *
 * These tests exercise read_passwd_hash() entirely through mock fgets —
 * no real file on disk is required. mock_fdopen_ok returns a non-NULL
 * FILE* sentinel; mock_fgets ignores the stream argument and serves content
 * from g_mock_fgets_content (set via setup_fgets_mock()). This is the same
 * abstraction already used by the login.defs parser tests.
 * ============================================================================
 */

TEST(read_passwd_hash_success) {
  /*
   * Inject a known hash string via setup_fgets_mock.
   * read_passwd_hash must strip the newline and return the hash unchanged.
   */
  const char known_hash[] = "$6$rounds=65536$testsalt$fakehashvalue";
  setup_fgets_mock(known_hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.fdopen = mock_fdopen_ok;
  ops.fgets  = mock_fgets;
  ops.fclose = mock_fclose_noop;

  char buf[HASH_BUF_SIZE];
  /* fd=42 is a non-negative sentinel ignored by mock_fdopen_ok */
  int rc = read_passwd_hash(&ops, 42, buf, sizeof(buf));
  TEST_ASSERT_EQ(rc, 0, "read_passwd_hash should succeed");
  TEST_ASSERT_STR_EQ(buf, known_hash, "Hash content must match injected data");
}

TEST(read_passwd_hash_with_newline) {
  /*
   * Verify trailing newline is stripped from the stored hash.
   * The password file stores "<hash>\n"; read_passwd_hash returns only <hash>.
   */
  setup_fgets_mock("$6$rounds=65536$testsalt$fakehash\n");

  struct syscall_ops ops = syscall_ops_default;
  ops.fdopen = mock_fdopen_ok;
  ops.fgets  = mock_fgets;
  ops.fclose = mock_fclose_noop;

  char buf[HASH_BUF_SIZE];
  int rc = read_passwd_hash(&ops, 42, buf, sizeof(buf));
  TEST_ASSERT_EQ(rc, 0, "read_passwd_hash should succeed");
  /* Trailing newline must be stripped */
  char *nl = strchr(buf, '\n');
  TEST_ASSERT_EQ(nl, NULL, "Trailing newline must be stripped from hash");
  TEST_ASSERT_STR_EQ(buf, "$6$rounds=65536$testsalt$fakehash",
                     "Hash without newline should match");
}

TEST(read_passwd_hash_empty_file) {
  /*
   * Empty file — fgets returns NULL immediately (EOF).
   * Must fail with ENODATA.
   */
  setup_fgets_mock(""); /* mock_fgets returns NULL for empty string */

  struct syscall_ops ops = syscall_ops_default;
  ops.fdopen = mock_fdopen_ok;
  ops.fgets  = mock_fgets;
  ops.fclose = mock_fclose_noop;

  char buf[HASH_BUF_SIZE];
  int rc = read_passwd_hash(&ops, 42, buf, sizeof(buf));
  TEST_ASSERT_EQ(rc, -1, "Empty file should return -1");
  TEST_ASSERT_EQ(errno, ENODATA, "Empty file errno should be ENODATA");
}

TEST(read_passwd_hash_read_fails) {
  /*
   * fgets returns NULL (e.g. I/O error) — must fail with ENODATA.
   * Uses the same empty-content path; from read_passwd_hash's perspective
   * a NULL from fgets is treated uniformly as an unreadable file.
   */
  setup_fgets_mock(""); /* NULL return from mock_fgets */

  struct syscall_ops ops = syscall_ops_default;
  ops.fdopen = mock_fdopen_ok;
  ops.fgets  = mock_fgets;
  ops.fclose = mock_fclose_noop;

  char buf[HASH_BUF_SIZE];
  int rc = read_passwd_hash(&ops, 42, buf, sizeof(buf));
  TEST_ASSERT_EQ(rc, -1, "fgets error should return -1");
}

TEST(read_passwd_hash_null_ops) {
  char buf[HASH_BUF_SIZE];
  errno = 0;
  int rc = read_passwd_hash(NULL, -1, buf, sizeof(buf));
  TEST_ASSERT_EQ(rc, -1, "NULL ops should return -1");
  TEST_ASSERT_EQ(errno, EINVAL, "NULL ops should set errno to EINVAL");
}

/* ============================================================================
 * Tests: PAM Argument Parsing
 * ============================================================================
 */

TEST(parse_args_no_args) {
  struct pam_args args;
  parse_pam_args(0, NULL, &args);
  TEST_ASSERT_EQ(args.file, NULL, "No file override");
  TEST_ASSERT_EQ((long)args.nullok, 0L, "nullok should be false");
}

TEST(parse_args_file_override) {
  struct pam_args args;
  const char *argv[] = { "file=/custom/path/fnal_vncpasswd" };
  parse_pam_args(1, argv, &args);
  TEST_ASSERT_STR_EQ(args.file, "/custom/path/fnal_vncpasswd", "File override");
}

TEST(parse_args_nullok) {
  struct pam_args args;
  const char *argv[] = { "nullok" };
  parse_pam_args(1, argv, &args);
  TEST_ASSERT_EQ((long)args.nullok, 1L, "nullok should be true");
}

TEST(parse_args_multiple) {
  struct pam_args args;
  const char *argv[] = { "file=/some/path", "nullok" };
  parse_pam_args(2, argv, &args);
  TEST_ASSERT_STR_EQ(args.file, "/some/path", "File override set");
  TEST_ASSERT_EQ((long)args.nullok, 1L, "nullok should be true");
}

TEST(parse_args_unknown_arg) {
  struct pam_args args;
  const char *argv[] = { "debug", "verbose", "nullok" };
  parse_pam_args(3, argv, &args);
  TEST_ASSERT_EQ((long)args.nullok, 1L, "nullok should be true");
  TEST_ASSERT_EQ(args.file, NULL, "No file override");
}

/* ============================================================================
 * Tests: Core Authentication Logic
 * ============================================================================
 */

static char g_auth_tmpfile[64];

static void setup_auth_hash_file(const char *hash) {
  snprintf(g_auth_tmpfile, sizeof(g_auth_tmpfile),
           "/tmp/test_fnal_pam_auth_XXXXXX");
  int fd = mkstemp(g_auth_tmpfile);
  fchmod(fd, 0600);
  write(fd, hash, strlen(hash));
  write(fd, "\n", 1);
  close(fd);
}
static void cleanup_auth_hash_file(void) { unlink(g_auth_tmpfile); }

static int mock_auth_open(const char *p, int f, ...) {
  (void)p; (void)f;
  return open(g_auth_tmpfile, O_RDONLY);
}

TEST(pam_auth_success) {
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("goodpass", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  g_mock_pw_uid = getuid();
  memset(&g_mock_pw, 0, sizeof(g_mock_pw));
  char pw_dir_buf[] = "/tmp";
  g_mock_pw.pw_dir = pw_dir_buf;
  g_mock_pw.pw_uid = g_mock_pw_uid;
  ops.getpwnam_r = mock_getpwnam_r_ok;
  g_mock_mlock_called = 0;
  g_mock_munlock_called = 0;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "testuser", "goodpass", g_auth_tmpfile, false),
      PAM_SUCCESS, "Correct password should return PAM_SUCCESS");
  cleanup_auth_hash_file();
}

TEST(pam_auth_wrong_password) {
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("correct", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "u", "wrong", g_auth_tmpfile, false),
      PAM_AUTH_ERR, "Wrong password should return PAM_AUTH_ERR");
  cleanup_auth_hash_file();
}

/*
 * A password longer than MAX_PASSWORD_LENGTH could never have been stored
 * (fnal-vncpasswd rejects it at set-time), so it will never match the
 * stored hash. The PAM module must return PAM_AUTH_ERR — not a special
 * "password too long" error — so the caller learns nothing about why
 * authentication failed.
 */
TEST(pam_auth_password_too_long) {
  char hash[HASH_BUF_SIZE];
  /* Store a valid 8-char password */
  make_sha512_hash("exactly8", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  /* Attempt to authenticate with a 9+ character password */
  const char *long_password = "toolongpassword";
  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "u", long_password, g_auth_tmpfile, false),
      PAM_AUTH_ERR,
      "Password longer than MAX_PASSWORD_LENGTH must return PAM_AUTH_ERR");
  cleanup_auth_hash_file();
}

TEST(pam_auth_no_password_file) {
  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_open_fail;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;
  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "u", "pass", "/nonexistent", false),
      PAM_AUTHINFO_UNAVAIL, "Missing file → PAM_AUTHINFO_UNAVAIL");
}

TEST(pam_auth_no_password_file_nullok) {
  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_open_fail;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;
  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "u", "pass", "/nonexistent", true),
      PAM_SUCCESS, "Missing file with nullok → PAM_SUCCESS");
}

TEST(pam_auth_null_user) {
  struct syscall_ops ops = syscall_ops_default;
  TEST_ASSERT_EQ(authenticate_vnc_user(&ops, NULL, "pass", NULL, false),
                 PAM_AUTH_ERR, "NULL user → PAM_AUTH_ERR");
}

TEST(pam_auth_null_authtok) {
  struct syscall_ops ops = syscall_ops_default;
  TEST_ASSERT_EQ(authenticate_vnc_user(&ops, "user", NULL, NULL, false),
                 PAM_AUTH_ERR, "NULL authtok → PAM_AUTH_ERR");
}

TEST(pam_auth_user_not_in_passwd) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getpwnam_r = mock_getpwnam_r_notfound;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;
  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "nosuchuser", "pass", NULL, false),
      PAM_USER_UNKNOWN, "Unknown user → PAM_USER_UNKNOWN");
}

TEST(pam_auth_file_argument) {
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("correct", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;
  /* getpwnam_r should NOT be called with file= override */
  ops.getpwnam_r = mock_getpwnam_r_fail;

  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "u", "correct", g_auth_tmpfile, false),
      PAM_SUCCESS, "file= override should bypass getpwnam_r");
  cleanup_auth_hash_file();
}

TEST(pam_auth_mlock_failure_continues) {
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("testpass", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_fail;
  ops.munlock = mock_munlock_ok;
  g_mock_mlock_called = 0;

  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "u", "testpass", g_auth_tmpfile, false),
      PAM_SUCCESS, "mlock failure must not abort auth");
  TEST_ASSERT_NOT_EQ(g_mock_mlock_called, 0, "mlock should have been called");
  cleanup_auth_hash_file();
}

/* yescrypt end-to-end authentication */
TEST(pam_auth_yescrypt_success) {
  char hash[HASH_BUF_SIZE];
  make_yescrypt_hash("yescrypt1", hash, sizeof(hash));
  TEST_ASSERT_EQ(strncmp(hash, "$y$", 3), 0, "Hash should be yescrypt");
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  TEST_ASSERT_EQ(
      authenticate_vnc_user(&ops, "u", "yescrypt1", g_auth_tmpfile, false),
      PAM_SUCCESS, "yescrypt password should authenticate");
  cleanup_auth_hash_file();
}

/* ============================================================================
 * Tests: PAM return code values
 * ============================================================================
 */

TEST(pam_return_codes_values) {
  TEST_ASSERT_EQ(PAM_SUCCESS, 0, "PAM_SUCCESS must be 0");
  TEST_ASSERT_EQ(PAM_AUTH_ERR, 7, "PAM_AUTH_ERR must be 7");
  TEST_ASSERT_EQ(PAM_AUTHINFO_UNAVAIL, 9, "PAM_AUTHINFO_UNAVAIL must be 9");
  TEST_ASSERT_EQ(PAM_USER_UNKNOWN, 10, "PAM_USER_UNKNOWN must be 10");
}

/* ============================================================================
 * Tests: ensure_dir (multi-segment path creation)
 * ============================================================================
 */

static int mock_lstat_noent(const char *p, struct stat *st) {
  (void)p; (void)st; errno = ENOENT; return -1;
}
static int mock_lstat_isdir(const char *p, struct stat *st) {
  (void)p; memset(st, 0, sizeof(*st)); st->st_mode = S_IFDIR | 0700; return 0;
}
static int mock_lstat_isfile(const char *p, struct stat *st) {
  (void)p; memset(st, 0, sizeof(*st)); st->st_mode = S_IFREG | 0600; return 0;
}
static int mock_mkdir_ok(const char *p, mode_t m) { (void)p; (void)m; return 0; }
static int mock_mkdir_fail(const char *p, mode_t m) {
  (void)p; (void)m; errno = EACCES; return -1;
}

TEST(ensure_dir_creates_new) {
  struct syscall_ops ops = syscall_ops_default;
  ops.lstat = mock_lstat_noent;
  ops.mkdir = mock_mkdir_ok;
  TEST_ASSERT_EQ(ensure_dir(&ops, "/tmp/fakenewdir"), 0,
                 "Should create new directory");
}

TEST(ensure_dir_already_exists) {
  struct syscall_ops ops = syscall_ops_default;
  ops.lstat = mock_lstat_isdir;
  ops.mkdir = mock_mkdir_fail; /* must not be called */
  TEST_ASSERT_EQ(ensure_dir(&ops, "/tmp/existingdir"), 0,
                 "Existing directory should succeed");
}

TEST(ensure_dir_mkdir_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.lstat = mock_lstat_noent;
  ops.mkdir = mock_mkdir_fail;
  TEST_ASSERT_EQ(ensure_dir(&ops, "/tmp/faildir"), -1,
                 "Should fail when mkdir fails");
}

TEST(ensure_dir_not_a_directory) {
  struct syscall_ops ops = syscall_ops_default;
  ops.lstat = mock_lstat_isfile;
  TEST_ASSERT_EQ(ensure_dir(&ops, "/tmp/notadir"), -1,
                 "Non-directory path should fail");
  TEST_ASSERT_EQ(errno, ENOTDIR, "Should set ENOTDIR");
}

TEST(ensure_dir_null_path) {
  struct syscall_ops ops = syscall_ops_default;
  TEST_ASSERT_EQ(ensure_dir(&ops, NULL), -1, "NULL path should fail");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

/*
 * Paths containing ".." sequences must be rejected to prevent directory
 * traversal attacks.  ensure_dir() validates the whole path string before
 * creating any directories.
 */
TEST(ensure_dir_dotdot_rejected) {
  struct syscall_ops ops = syscall_ops_default;
  ops.lstat = mock_lstat_noent;
  ops.mkdir = mock_mkdir_ok;
  TEST_ASSERT_EQ(ensure_dir(&ops, "/tmp/a/../b"), -1,
                 "Path with /../ should be rejected");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL for /../");
  TEST_ASSERT_EQ(ensure_dir(&ops, "../relative"), -1,
                 "Path starting with ../ should be rejected");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL for ../");
  TEST_ASSERT_EQ(ensure_dir(&ops, "/tmp/a/.."), -1,
                 "Path ending with /.. should be rejected");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL for /..");
}

/* ============================================================================
 * Test Runner
 * ============================================================================
 */

int main(int argc, char **argv) {
  TEST_INIT(32, false, false);

  /* login.defs parsing */
  RUN_TEST(get_encrypt_method_sha512);
  RUN_TEST(get_encrypt_method_sha256);
  RUN_TEST(get_encrypt_method_yescrypt);
  RUN_TEST(get_encrypt_method_blowfish);
  RUN_TEST(get_encrypt_method_missing);
  RUN_TEST(get_encrypt_method_empty_value);
  RUN_TEST(get_encrypt_method_file_not_found);
  RUN_TEST(get_encrypt_method_with_comments);
  RUN_TEST(get_encrypt_method_with_leading_whitespace);
  RUN_TEST(get_encrypt_method_case_insensitive_key);
  RUN_TEST(get_encrypt_method_null_ops);
  RUN_TEST(get_yescrypt_cost_factor);
  RUN_TEST(get_sha_crypt_rounds);

  /* Salt generation */
  RUN_TEST(generate_salt_sha512_prefix);
  RUN_TEST(generate_salt_sha256_prefix);
  RUN_TEST(generate_salt_yescrypt_prefix);
  RUN_TEST(generate_salt_yescrypt_cost_encoded);
  RUN_TEST(generate_salt_sufficient_length);
  RUN_TEST(generate_salt_getrandom_fails);
  RUN_TEST(generate_salt_null_buffer);
  RUN_TEST(generate_salt_crypt_gensalt_ra_fails);

  /* Password hashing and verification */
  RUN_TEST(hash_password_sha512);
  RUN_TEST(hash_password_sha256);
  RUN_TEST(hash_password_yescrypt);
  RUN_TEST(hash_password_null_password);
  RUN_TEST(hash_password_empty_password);
  RUN_TEST(hash_password_crypt_r_fails);
  RUN_TEST(hash_password_getrandom_fails);
  RUN_TEST(verify_password_correct);
  RUN_TEST(verify_password_incorrect);
  RUN_TEST(verify_password_yescrypt);
  RUN_TEST(verify_password_constant_time);
  RUN_TEST(verify_password_different_lengths);
  RUN_TEST(verify_password_null_inputs);
  RUN_TEST(verify_password_crypt_r_fails);

  /* Password file validation */
  RUN_TEST(validate_passwd_file_good);
  RUN_TEST(validate_passwd_file_world_readable);
  RUN_TEST(validate_passwd_file_group_readable);
  RUN_TEST(validate_passwd_file_wrong_owner);
  RUN_TEST(validate_passwd_file_not_regular);
  RUN_TEST(validate_passwd_file_open_fails);
  RUN_TEST(validate_passwd_file_fstat_fails);

  /* read_passwd_hash — exercises ops->read mock */
  RUN_TEST(read_passwd_hash_success);
  RUN_TEST(read_passwd_hash_with_newline);
  RUN_TEST(read_passwd_hash_empty_file);
  RUN_TEST(read_passwd_hash_read_fails);
  RUN_TEST(read_passwd_hash_null_ops);

  /* PAM argument parsing */
  RUN_TEST(parse_args_no_args);
  RUN_TEST(parse_args_file_override);
  RUN_TEST(parse_args_nullok);
  RUN_TEST(parse_args_multiple);
  RUN_TEST(parse_args_unknown_arg);

  /* Core authentication */
  RUN_TEST(pam_auth_success);
  RUN_TEST(pam_auth_wrong_password);
  RUN_TEST(pam_auth_password_too_long);
  RUN_TEST(pam_auth_no_password_file);
  RUN_TEST(pam_auth_no_password_file_nullok);
  RUN_TEST(pam_auth_null_user);
  RUN_TEST(pam_auth_null_authtok);
  RUN_TEST(pam_auth_user_not_in_passwd);
  RUN_TEST(pam_auth_file_argument);
  RUN_TEST(pam_auth_mlock_failure_continues);
  RUN_TEST(pam_auth_yescrypt_success);

  /* PAM return code values */
  RUN_TEST(pam_return_codes_values);

  /* ensure_dir */
  RUN_TEST(ensure_dir_creates_new);
  RUN_TEST(ensure_dir_already_exists);
  RUN_TEST(ensure_dir_mkdir_fails);
  RUN_TEST(ensure_dir_not_a_directory);
  RUN_TEST(ensure_dir_null_path);
  RUN_TEST(ensure_dir_dotdot_rejected);

  return TEST_EXECUTE();
}
