/**
 * test_pam_vncpasswd.c - Tests for PAM module core functions
 *
 * Tests the functions in pam_vncpasswd.c that do not depend on PAM headers:
 * get_encrypt_settings(), generate_salt(), hash_password(), verify_password(),
 * validate_passwd_file(), authenticate_vnc_user(), parse_pam_args().
 *
 * Uses the syscall_ops mock pattern from fermitools/static-subid:
 * copy syscall_ops_default, override specific fields for each test.
 *
 * YESCRYPT NOTES:
 * yescrypt is the default ENCRYPT_METHOD on modern RHEL/Fedora.
 * Its salt is generated by crypt_gensalt_ra("$y$", cost_factor, ...) where
 * cost_factor comes from YESCRYPT_COST_FACTOR in login.defs (default 5).
 * The resulting salt looks like "$y$j9T$<base64>$" (not "rounds=N$").
 * Tests verify yescrypt cost is parsed separately from SHA_CRYPT_MAX_ROUNDS.
 */

#include "autoconf.h"
#include "pam_vncpasswd.h"
#include "syscall_ops.h"

#include <crypt.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "test_framework.h"

/*
 * Minimal PAM return code definitions for tests.
 * These must match the integer values in <security/pam_modules.h>.
 */
#ifndef PAM_SUCCESS
#define PAM_SUCCESS          0
#define PAM_AUTH_ERR         7
#define PAM_AUTHINFO_UNAVAIL 9
#define PAM_USER_UNKNOWN     10
#define PAM_AUTHTOK_ERR      20
#endif

/* ============================================================================
 * Mock Infrastructure
 * ============================================================================
 */

/* Shared mock state - reset between tests by declaring locally */
static char g_mock_fgets_content[4096];
static int g_mock_fgets_called;
static int g_mock_fstat_mode;
static uid_t g_mock_fstat_uid;
static int g_mock_fstat_type; /* S_IFREG=1, S_IFLNK=2, other=3 */
static int g_mock_mlock_called;
static int g_mock_munlock_called;
static const char *g_mock_pw_dir;

/* fgets mock: returns lines from g_mock_fgets_content */
static char *mock_fgets(char *str, int n, FILE *stream) {
  (void)stream;
  static char *pos;
  if (!g_mock_fgets_called) {
    pos = g_mock_fgets_content;
    g_mock_fgets_called = 1;
  }
  if (!pos || *pos == '\0')
    return NULL;
  char *dst = str;
  int written = 0;
  while (*pos && written < n - 1) {
    *dst++ = *pos;
    written++;
    if (*pos++ == '\n')
      break;
  }
  *dst = '\0';
  return (written > 0) ? str : NULL;
}

/* fopen mock */
static FILE *mock_fopen_ok(const char *p, const char *m) {
  (void)p; (void)m;
  return (FILE *)0x1; /* non-NULL sentinel */
}
static FILE *mock_fopen_fail(const char *p, const char *m) {
  (void)p; (void)m;
  errno = ENOENT;
  return NULL;
}
static int mock_fclose_noop(FILE *f) { (void)f; return 0; }

/* getrandom mock: fills with deterministic bytes (0x42) */
static ssize_t mock_getrandom_ok(void *buf, size_t len, unsigned int flags) {
  (void)flags;
  memset(buf, 0x42, len);
  return (ssize_t)len;
}
static ssize_t mock_getrandom_fail_fn(void *buf, size_t len,
                                       unsigned int flags) {
  (void)buf; (void)len; (void)flags;
  errno = EIO;
  return -1;
}

/* crypt_gensalt_ra mock */
static char *mock_crypt_gensalt_ra_fail(const char *p, unsigned long c,
                                         const char *r, int n) {
  (void)p; (void)c; (void)r; (void)n;
  return NULL;
}

/* crypt_r mock: returns a predictable hash */
static struct crypt_data g_real_cd;
static char *mock_crypt_r_fail(const char *phrase, const char *setting,
                               struct crypt_data *data) {
  (void)phrase; (void)setting; (void)data;
  return NULL;
}

/* open mock */
static int mock_open_fail_fn(const char *p, int f, ...) {
  (void)p; (void)f;
  errno = ENOENT;
  return -1;
}

/* fstat mock */
static int mock_fstat_ok(int fd, struct stat *st) {
  (void)fd;
  memset(st, 0, sizeof(*st));
  st->st_uid = g_mock_fstat_uid;
  if (g_mock_fstat_type == 2)
    st->st_mode = (mode_t)(S_IFLNK | 0600);
  else if (g_mock_fstat_type == 3)
    st->st_mode = (mode_t)(S_IFBLK | 0600);
  else
    st->st_mode = (mode_t)(S_IFREG | (g_mock_fstat_mode & 0777));
  return 0;
}
static int mock_fstat_fail(int fd, struct stat *st) {
  (void)fd; (void)st;
  errno = EIO;
  return -1;
}

/* mlock/munlock mocks */
static int mock_mlock_ok(const void *a, size_t l) {
  (void)a; (void)l;
  g_mock_mlock_called++;
  return 0;
}
static int mock_mlock_fail(const void *a, size_t l) {
  (void)a; (void)l;
  g_mock_mlock_called++;
  errno = EPERM;
  return -1;
}
static int mock_munlock_ok(const void *a, size_t l) {
  (void)a; (void)l;
  g_mock_munlock_called++;
  return 0;
}

/* getpwnam_r mock */
static struct passwd g_mock_pw;
static int mock_getpwnam_r_ok(const char *name, struct passwd *pw,
                               char *buf, size_t buflen,
                               struct passwd **result) {
  (void)name; (void)buf; (void)buflen;
  *pw = g_mock_pw;
  *result = pw;
  return 0;
}
static int mock_getpwnam_r_fail(const char *name, struct passwd *pw,
                                 char *buf, size_t buflen,
                                 struct passwd **result) {
  (void)name; (void)pw; (void)buf; (void)buflen;
  *result = NULL;
  return ENOENT;
}
static int mock_getpwnam_r_notfound(const char *name, struct passwd *pw,
                                     char *buf, size_t buflen,
                                     struct passwd **result) {
  (void)name; (void)pw; (void)buf; (void)buflen;
  *result = NULL;
  return 0; /* not found but no error */
}

/* Helper: build a test ops with fgets returning the given content */
static void setup_fgets_mock(const char *content) {
  g_mock_fgets_called = 0;
  snprintf(g_mock_fgets_content, sizeof(g_mock_fgets_content), "%s", content);
}

/* ============================================================================
 * Helper: build a valid SHA-512 hash for testing
 * ============================================================================
 */
static void make_sha512_hash(const char *password, char *hash_out,
                             size_t hash_len) {
  struct crypt_data cd;
  memset(&cd, 0, sizeof(cd));
  char *h = crypt_r(password, "$6$rounds=65536$testsalt", &cd);
  if (h)
    snprintf(hash_out, hash_len, "%s", h);
}

/* Helper: build a valid yescrypt hash for testing */
static void make_yescrypt_hash(const char *password, char *hash_out,
                               size_t hash_len) {
  struct crypt_data cd;
  memset(&cd, 0, sizeof(cd));
  /* Use crypt_gensalt_ra for a proper yescrypt salt */
  char rbytes[16];
  memset(rbytes, 0x77, sizeof(rbytes));
  char *salt = crypt_gensalt_ra("$y$", 5UL, rbytes, (int)sizeof(rbytes));
  if (!salt) return;
  char *h = crypt_r(password, salt, &cd);
  if (h)
    snprintf(hash_out, hash_len, "%s", h);
  free(salt);
}

/* ============================================================================
 * Tests: login.defs Parsing
 * ============================================================================
 */

TEST(get_encrypt_method_sha512) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD SHA512\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "SHA512", "Method should be SHA512");
}

TEST(get_encrypt_method_sha256) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD SHA256\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "SHA256", "Method should be SHA256");
}

/*
 * yescrypt is the default ENCRYPT_METHOD on modern RHEL/Fedora.
 * We verify both that the method is parsed AND that the cost factor
 * is read from YESCRYPT_COST_FACTOR (NOT from SHA_CRYPT_MAX_ROUNDS).
 */
TEST(get_encrypt_method_yescrypt) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD YESCRYPT\nYESCRYPT_COST_FACTOR 11\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "YESCRYPT", "Method should be YESCRYPT");
  TEST_ASSERT_EQ((long)s.yescrypt_cost, 11L,
                 "Yescrypt cost should be 11");
}

TEST(get_encrypt_method_blowfish) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD BLOWFISH\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "BLOWFISH", "Method should be BLOWFISH");
}

TEST(get_encrypt_method_missing) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("# no ENCRYPT_METHOD here\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, DEFAULT_ENCRYPT_METHOD,
                     "Should use default method");
}

TEST(get_encrypt_method_empty_value) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, DEFAULT_ENCRYPT_METHOD,
                     "Should fall back to default");
}

TEST(get_encrypt_method_file_not_found) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  ops.fopen = mock_fopen_fail;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Missing file should not be an error");
  TEST_ASSERT_STR_EQ(s.method, DEFAULT_ENCRYPT_METHOD,
                     "Should use default method");
}

TEST(get_encrypt_method_with_comments) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("# Comment\nENCRYPT_METHOD SHA512\n# Another comment\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "SHA512", "Method should be SHA512");
}

TEST(get_encrypt_method_with_leading_whitespace) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("  ENCRYPT_METHOD   SHA512\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_STR_EQ(s.method, "SHA512", "Method should be SHA512");
}

/* login.defs key matching is case-sensitive */
TEST(get_encrypt_method_case_insensitive_key) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("encrypt_method sha512\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  /* Lowercase key should NOT match — case sensitive per login.defs spec */
  TEST_ASSERT_STR_EQ(s.method, DEFAULT_ENCRYPT_METHOD,
                     "Lowercase key should not match");
}

TEST(get_encrypt_method_null_ops) {
  struct encrypt_settings s;
  TEST_ASSERT_EQ(get_encrypt_settings(NULL, "/etc/login.defs", &s), -1,
                 "NULL ops should return -1");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

/*
 * Verify that yescrypt cost is read from YESCRYPT_COST_FACTOR and
 * SHA rounds are read from SHA_CRYPT_MAX_ROUNDS — these are separate
 * directives for separate algorithms.
 */
TEST(get_yescrypt_cost_factor) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD YESCRYPT\n"
                   "YESCRYPT_COST_FACTOR 7\n"
                   "SHA_CRYPT_MAX_ROUNDS 100000\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_EQ((long)s.yescrypt_cost, 7L,
                 "yescrypt cost should be 7");
  TEST_ASSERT_EQ((long)s.sha_rounds, 100000L,
                 "SHA rounds should be 100000");
}

TEST(get_sha_crypt_rounds) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s;
  setup_fgets_mock("ENCRYPT_METHOD SHA512\nSHA_CRYPT_MAX_ROUNDS 131072\n");
  ops.fopen = mock_fopen_ok;
  ops.fclose = mock_fclose_noop;
  ops.fgets = mock_fgets;
  TEST_ASSERT_EQ(get_encrypt_settings(&ops, "/etc/login.defs", &s), 0,
                 "Should return 0");
  TEST_ASSERT_EQ((long)s.sha_rounds, 131072L,
                 "SHA rounds should be 131072");
}

/* ============================================================================
 * Tests: Salt Generation
 * ============================================================================
 */

TEST(generate_salt_sha512_prefix) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), 0,
                 "Should succeed");
  /* SHA-512 salt must start with $6$ and contain rounds= */
  TEST_ASSERT_EQ(strncmp(salt, "$6$", 3), 0, "Should start with $6$");
  TEST_ASSERT_NOT_EQ(strstr(salt, "rounds=65536"), NULL,
                     "Should contain rounds=65536");
}

TEST(generate_salt_sha256_prefix) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA256", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), 0,
                 "Should succeed");
  TEST_ASSERT_EQ(strncmp(salt, "$5$", 3), 0, "Should start with $5$");
  TEST_ASSERT_NOT_EQ(strstr(salt, "rounds=65536"), NULL,
                     "Should contain rounds=65536");
}

/*
 * yescrypt salt does NOT contain "rounds=N" — it uses a different
 * cost encoding embedded in the parameter string (e.g., "$y$j9T$").
 * This test verifies the prefix and absence of SHA-crypt rounds syntax.
 */
TEST(generate_salt_yescrypt_prefix) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "YESCRYPT", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), 0,
                 "Should succeed");
  /* yescrypt salt starts with $y$ */
  TEST_ASSERT_EQ(strncmp(salt, "$y$", 3), 0, "Should start with $y$");
  /* yescrypt does NOT use "rounds=N" syntax */
  TEST_ASSERT_EQ(strstr(salt, "rounds="), NULL,
                 "yescrypt salt must not contain rounds= prefix");
}

/*
 * Verify that different yescrypt cost factors produce different salt prefixes.
 * cost=5 → "$y$j9T$..." (N=32768)
 * cost=11 → "$y$jFT$..." (higher N)
 */
TEST(generate_salt_yescrypt_cost_encoded) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;

  char salt5[SALT_BUF_SIZE], salt11[SALT_BUF_SIZE];
  struct encrypt_settings s5 = { "YESCRYPT", 65536UL, 5UL };
  struct encrypt_settings s11 = { "YESCRYPT", 65536UL, 11UL };

  TEST_ASSERT_EQ(generate_salt(&ops, &s5, salt5, sizeof(salt5)), 0,
                 "Should generate salt with cost=5");
  TEST_ASSERT_EQ(generate_salt(&ops, &s11, salt11, sizeof(salt11)), 0,
                 "Should generate salt with cost=11");

  /* Both start with $y$ */
  TEST_ASSERT_EQ(strncmp(salt5, "$y$", 3), 0, "cost=5 salt starts with $y$");
  TEST_ASSERT_EQ(strncmp(salt11, "$y$", 3), 0, "cost=11 salt starts with $y$");

  /*
   * The parameter section (between 2nd and 3rd $) must differ between
   * cost=5 and cost=11 — this confirms cost is encoded in the salt,
   * not passed as a separate "rounds=N" field.
   */
  TEST_ASSERT_STR_NOT_EQ(salt5, salt11, "Different costs must produce different salts");
}

TEST(generate_salt_sufficient_length) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), 0,
                 "Should succeed");
  TEST_ASSERT_NOT_EQ((long)strlen(salt), 0L, "Salt should not be empty");
}

TEST(generate_salt_getrandom_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_fail_fn;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), -1,
                 "Should fail when getrandom fails");
}

TEST(generate_salt_null_buffer) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  TEST_ASSERT_EQ(generate_salt(&ops, &s, NULL, SALT_BUF_SIZE), -1,
                 "NULL buffer should fail");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

TEST(generate_salt_crypt_gensalt_ra_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  ops.crypt_gensalt_ra = mock_crypt_gensalt_ra_fail;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char salt[SALT_BUF_SIZE];
  TEST_ASSERT_EQ(generate_salt(&ops, &s, salt, sizeof(salt)), -1,
                 "Should fail when crypt_gensalt_ra fails");
}

/* ============================================================================
 * Tests: Password Hashing and Verification
 * ============================================================================
 */

TEST(hash_password_sha512) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpassword", &s, hash, sizeof(hash)),
                 0, "Should succeed");
  TEST_ASSERT_EQ(strncmp(hash, "$6$", 3), 0, "Hash should use SHA-512");
}

TEST(hash_password_sha256) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "SHA256", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpassword", &s, hash, sizeof(hash)),
                 0, "Should succeed");
  TEST_ASSERT_EQ(strncmp(hash, "$5$", 3), 0, "Hash should use SHA-256");
}

/*
 * yescrypt hashing: verify the hash starts with $y$ (not $6$)
 * and that crypt_r can verify it.
 */
TEST(hash_password_yescrypt) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  struct encrypt_settings s = { "YESCRYPT", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpassword", &s, hash, sizeof(hash)),
                 0, "yescrypt hash_password should succeed");
  TEST_ASSERT_EQ(strncmp(hash, "$y$", 3), 0,
                 "yescrypt hash should start with $y$");
}

TEST(hash_password_null_password) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, NULL, &s, hash, sizeof(hash)), -1,
                 "NULL password should fail");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

TEST(hash_password_empty_password) {
  struct syscall_ops ops = syscall_ops_default;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "", &s, hash, sizeof(hash)), -1,
                 "Empty password should fail");
  TEST_ASSERT_EQ(errno, EINVAL, "Should set EINVAL");
}

TEST(hash_password_crypt_r_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_ok;
  ops.crypt_r = mock_crypt_r_fail;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpassword", &s, hash, sizeof(hash)),
                 -1, "Should fail when crypt_r fails");
}

TEST(hash_password_getrandom_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getrandom = mock_getrandom_fail_fn;
  struct encrypt_settings s = { "SHA512", 65536UL, 5UL };
  char hash[HASH_BUF_SIZE];
  TEST_ASSERT_EQ(hash_password(&ops, "testpassword", &s, hash, sizeof(hash)),
                 -1, "Should fail when getrandom fails");
}

TEST(verify_password_correct) {
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("correctpassword", hash, sizeof(hash));
  TEST_ASSERT_EQ(verify_password(&ops, "correctpassword", hash), 0,
                 "Correct password should verify");
}

TEST(verify_password_incorrect) {
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("correctpassword", hash, sizeof(hash));
  TEST_ASSERT_EQ(verify_password(&ops, "wrongpassword", hash), -1,
                 "Wrong password should fail");
}

/*
 * yescrypt password verification: hash a password with yescrypt, then
 * verify it using verify_password(). This exercises the full yescrypt
 * code path including crypt_r() with a $y$ hash.
 */
TEST(verify_password_yescrypt) {
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  make_yescrypt_hash("yescrypttest", hash, sizeof(hash));
  TEST_ASSERT_EQ(verify_password(&ops, "yescrypttest", hash), 0,
                 "Correct yescrypt password should verify");
  TEST_ASSERT_EQ(verify_password(&ops, "wrongpassword", hash), -1,
                 "Wrong password should fail yescrypt verify");
}

TEST(verify_password_constant_time) {
  /*
   * The constant-time property cannot be directly measured in a unit
   * test. We verify instead that:
   * 1. A correct password returns 0
   * 2. An incorrect password returns -1
   * 3. Strings of different lengths also return -1 (not crash/early exit)
   * The XOR accumulator in verify_password() ensures no early return.
   */
  struct syscall_ops ops = syscall_ops_default;
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("secret", hash, sizeof(hash));
  TEST_ASSERT_EQ(verify_password(&ops, "secret", hash), 0,
                 "Correct password should match");
  TEST_ASSERT_EQ(verify_password(&ops, "s", hash), -1,
                 "Short password should not match");
  TEST_ASSERT_EQ(verify_password(&ops, "secretbutlonger", hash), -1,
                 "Longer password should not match");
}

TEST(verify_password_null_inputs) {
  struct syscall_ops ops = syscall_ops_default;
  TEST_ASSERT_EQ(verify_password(&ops, NULL, "$6$salt$hash"), -1,
                 "NULL password should fail");
  TEST_ASSERT_EQ(verify_password(&ops, "pass", NULL), -1,
                 "NULL hash should fail");
}

TEST(verify_password_crypt_r_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.crypt_r = mock_crypt_r_fail;
  TEST_ASSERT_EQ(verify_password(&ops, "password", "$6$salt$hash"), -1,
                 "Should fail when crypt_r fails");
}

/* ============================================================================
 * Tests: Password File Validation
 * ============================================================================
 */

TEST(validate_passwd_file_good) {
  struct syscall_ops ops = syscall_ops_default;
  /* We need a real file for this test */
  char tmpfile[] = "/tmp/test_vnc_passwd_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  fchmod(fd, 0600);
  close(fd);

  uid_t myuid = getuid();
  int result = validate_passwd_file(&ops, tmpfile, myuid);
  TEST_ASSERT_NOT_EQ(result, -1, "Good file should validate");
  if (result >= 0)
    close(result);
  unlink(tmpfile);
}

TEST(validate_passwd_file_world_readable) {
  struct syscall_ops ops = syscall_ops_default;
  char tmpfile[] = "/tmp/test_vnc_world_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  fchmod(fd, 0644);
  close(fd);

  uid_t myuid = getuid();
  int result = validate_passwd_file(&ops, tmpfile, myuid);
  TEST_ASSERT_EQ(result, -1, "World-readable file should be rejected");
  unlink(tmpfile);
}

TEST(validate_passwd_file_group_readable) {
  struct syscall_ops ops = syscall_ops_default;
  char tmpfile[] = "/tmp/test_vnc_grp_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  fchmod(fd, 0640);
  close(fd);

  uid_t myuid = getuid();
  int result = validate_passwd_file(&ops, tmpfile, myuid);
  TEST_ASSERT_EQ(result, -1, "Group-readable file should be rejected");
  unlink(tmpfile);
}

TEST(validate_passwd_file_wrong_owner) {
  struct syscall_ops ops = syscall_ops_default;
  /* Override fstat to return a different owner */
  g_mock_fstat_uid = 9999;
  g_mock_fstat_mode = 0600;
  g_mock_fstat_type = 1; /* regular file */
  ops.fstat = mock_fstat_ok;

  char tmpfile[] = "/tmp/test_vnc_owner_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  close(fd);

  int result = validate_passwd_file(&ops, tmpfile, getuid());
  TEST_ASSERT_EQ(result, -1, "Wrong owner file should be rejected");
  unlink(tmpfile);
}

TEST(validate_passwd_file_not_regular) {
  struct syscall_ops ops = syscall_ops_default;
  g_mock_fstat_uid = getuid();
  g_mock_fstat_mode = 0600;
  g_mock_fstat_type = 3; /* block device or other non-regular */
  ops.fstat = mock_fstat_ok;

  char tmpfile[] = "/tmp/test_vnc_notreg_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  close(fd);

  int result = validate_passwd_file(&ops, tmpfile, getuid());
  TEST_ASSERT_EQ(result, -1, "Non-regular file should be rejected");
  unlink(tmpfile);
}

TEST(validate_passwd_file_open_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_open_fail_fn;
  int result = validate_passwd_file(&ops, "/nonexistent/path", getuid());
  TEST_ASSERT_EQ(result, -1, "Should fail when open fails");
}

TEST(validate_passwd_file_fstat_fails) {
  struct syscall_ops ops = syscall_ops_default;
  ops.fstat = mock_fstat_fail;

  char tmpfile[] = "/tmp/test_vnc_fstat_XXXXXX";
  int fd = mkstemp(tmpfile);
  TEST_ASSERT_NOT_EQ(fd, -1, "mkstemp should succeed");
  close(fd);

  int result = validate_passwd_file(&ops, tmpfile, getuid());
  TEST_ASSERT_EQ(result, -1, "Should fail when fstat fails");
  unlink(tmpfile);
}

/* ============================================================================
 * Tests: PAM Argument Parsing
 * ============================================================================
 */

TEST(parse_args_no_args) {
  struct pam_args args;
  parse_pam_args(0, NULL, &args);
  TEST_ASSERT_EQ(args.file, NULL, "No file override");
  TEST_ASSERT_EQ((long)args.nullok, 0L, "nullok should be false");
}

TEST(parse_args_file_override) {
  struct pam_args args;
  const char *argv[] = { "file=/custom/path/passwd" };
  parse_pam_args(1, argv, &args);
  TEST_ASSERT_STR_EQ(args.file, "/custom/path/passwd", "File override set");
}

TEST(parse_args_nullok) {
  struct pam_args args;
  const char *argv[] = { "nullok" };
  parse_pam_args(1, argv, &args);
  TEST_ASSERT_EQ((long)args.nullok, 1L, "nullok should be true");
}

TEST(parse_args_multiple) {
  struct pam_args args;
  const char *argv[] = { "file=/some/path", "nullok" };
  parse_pam_args(2, argv, &args);
  TEST_ASSERT_STR_EQ(args.file, "/some/path", "File override set");
  TEST_ASSERT_EQ((long)args.nullok, 1L, "nullok should be true");
}

TEST(parse_args_unknown_arg) {
  struct pam_args args;
  const char *argv[] = { "debug", "verbose", "nullok" };
  parse_pam_args(3, argv, &args);
  TEST_ASSERT_EQ((long)args.nullok, 1L, "nullok should be true");
  TEST_ASSERT_EQ(args.file, NULL, "No file override");
}

/* ============================================================================
 * Tests: Core Authentication Logic
 * ============================================================================
 */

/* Minimal open() that returns an fd to a real temp file with hash */
static char g_auth_tmpfile[64];
static int g_auth_tmpfd;

static void setup_auth_hash_file(const char *hash) {
  snprintf(g_auth_tmpfile, sizeof(g_auth_tmpfile),
           "/tmp/test_pam_auth_XXXXXX");
  g_auth_tmpfd = mkstemp(g_auth_tmpfile);
  fchmod(g_auth_tmpfd, 0600);
  write(g_auth_tmpfd, hash, strlen(hash));
  write(g_auth_tmpfd, "\n", 1);
  close(g_auth_tmpfd);
}
static void cleanup_auth_hash_file(void) { unlink(g_auth_tmpfile); }

static char g_auth_open_path[PAM_ARGS_FILE_MAX];
static int mock_auth_open(const char *p, int f, ...) {
  /* Return the fd to our temp file regardless of requested path */
  (void)f;
  snprintf(g_auth_open_path, sizeof(g_auth_open_path), "%s", p);
  int fd = open(g_auth_tmpfile, O_RDONLY);
  return fd;
}

TEST(pam_auth_success) {
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("goodpassword", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  g_mock_pw_dir = "/tmp";
  g_mock_pw_uid = getuid();
  memset(&g_mock_pw, 0, sizeof(g_mock_pw));
  g_mock_pw.pw_dir = (char *)g_mock_pw_dir;
  g_mock_pw.pw_uid = g_mock_pw_uid;
  ops.getpwnam_r = mock_getpwnam_r_ok;
  g_mock_mlock_called = 0;
  g_mock_munlock_called = 0;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  int rc = authenticate_vnc_user(&ops, "testuser", "goodpassword",
                                  g_auth_tmpfile, false);
  TEST_ASSERT_EQ(rc, PAM_SUCCESS, "Correct password should return PAM_SUCCESS");

  cleanup_auth_hash_file();
}

TEST(pam_auth_wrong_password) {
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("correctpassword", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  int rc = authenticate_vnc_user(&ops, "testuser", "wrongpassword",
                                  g_auth_tmpfile, false);
  TEST_ASSERT_EQ(rc, PAM_AUTH_ERR, "Wrong password should return PAM_AUTH_ERR");

  cleanup_auth_hash_file();
}

TEST(pam_auth_no_password_file) {
  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_open_fail_fn;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  int rc = authenticate_vnc_user(&ops, "testuser", "anypassword",
                                  "/nonexistent/file", false);
  TEST_ASSERT_EQ(rc, PAM_AUTHINFO_UNAVAIL,
                 "Missing file should return PAM_AUTHINFO_UNAVAIL");
}

TEST(pam_auth_no_password_file_nullok) {
  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_open_fail_fn;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  int rc = authenticate_vnc_user(&ops, "testuser", "anypassword",
                                  "/nonexistent/file", true);
  TEST_ASSERT_EQ(rc, PAM_SUCCESS,
                 "Missing file with nullok should return PAM_SUCCESS");
}

TEST(pam_auth_null_user) {
  struct syscall_ops ops = syscall_ops_default;
  int rc = authenticate_vnc_user(&ops, NULL, "password", NULL, false);
  TEST_ASSERT_EQ(rc, PAM_AUTH_ERR, "NULL user should return PAM_AUTH_ERR");
}

TEST(pam_auth_null_authtok) {
  struct syscall_ops ops = syscall_ops_default;
  int rc = authenticate_vnc_user(&ops, "testuser", NULL, NULL, false);
  TEST_ASSERT_EQ(rc, PAM_AUTH_ERR, "NULL authtok should return PAM_AUTH_ERR");
}

TEST(pam_auth_user_not_in_passwd) {
  struct syscall_ops ops = syscall_ops_default;
  ops.getpwnam_r = mock_getpwnam_r_notfound;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  int rc = authenticate_vnc_user(&ops, "nosuchuser", "password", NULL, false);
  TEST_ASSERT_EQ(rc, PAM_USER_UNKNOWN,
                 "Unknown user should return PAM_USER_UNKNOWN");
}

TEST(pam_auth_file_argument) {
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("correctpassword", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  /* With file= override, getpwnam_r should NOT be called */
  ops.getpwnam_r = mock_getpwnam_r_fail; /* would fail if called */

  int rc = authenticate_vnc_user(&ops, "testuser", "correctpassword",
                                  g_auth_tmpfile, false);
  TEST_ASSERT_EQ(rc, PAM_SUCCESS,
                 "file= override should bypass getpwnam_r");
  cleanup_auth_hash_file();
}

TEST(pam_auth_mlock_failure_continues) {
  /*
   * mlock() failure is non-fatal. Authentication should continue and
   * succeed even when the password cannot be locked in RAM.
   */
  char hash[HASH_BUF_SIZE];
  make_sha512_hash("testpassword", hash, sizeof(hash));
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_fail;
  ops.munlock = mock_munlock_ok;
  g_mock_mlock_called = 0;

  int rc = authenticate_vnc_user(&ops, "testuser", "testpassword",
                                  g_auth_tmpfile, false);
  TEST_ASSERT_EQ(rc, PAM_SUCCESS,
                 "mlock failure should not abort authentication");
  TEST_ASSERT_NOT_EQ(g_mock_mlock_called, 0, "mlock should have been called");
  cleanup_auth_hash_file();
}

/*
 * Verify yescrypt authentication end-to-end:
 * hash with yescrypt, store in file, verify via authenticate_vnc_user.
 */
TEST(pam_auth_yescrypt_success) {
  char hash[HASH_BUF_SIZE];
  make_yescrypt_hash("yescryptpassword", hash, sizeof(hash));
  TEST_ASSERT_EQ(strncmp(hash, "$y$", 3), 0,
                 "Hash should be yescrypt");
  setup_auth_hash_file(hash);

  struct syscall_ops ops = syscall_ops_default;
  ops.open = mock_auth_open;
  ops.mlock = mock_mlock_ok;
  ops.munlock = mock_munlock_ok;

  int rc = authenticate_vnc_user(&ops, "testuser", "yescryptpassword",
                                  g_auth_tmpfile, false);
  TEST_ASSERT_EQ(rc, PAM_SUCCESS,
                 "yescrypt password should authenticate successfully");
  cleanup_auth_hash_file();
}

/* ============================================================================
 * Tests: PAM Stubs
 * ============================================================================
 */

/*
 * pam_sm_setcred, pam_sm_acct_mgmt, pam_sm_open_session, and
 * pam_sm_close_session are all stubs that return PAM_SUCCESS.
 * We test them via authenticate_vnc_user returning correct codes,
 * since the stubs are in the PAM-linked build (HAVE_PAM guard).
 * Here we verify the PAM return code integer values used by the core.
 */
TEST(pam_return_codes_values) {
  TEST_ASSERT_EQ(PAM_SUCCESS, 0, "PAM_SUCCESS must be 0");
  TEST_ASSERT_EQ(PAM_AUTH_ERR, 7, "PAM_AUTH_ERR must be 7");
  TEST_ASSERT_EQ(PAM_AUTHINFO_UNAVAIL, 9, "PAM_AUTHINFO_UNAVAIL must be 9");
  TEST_ASSERT_EQ(PAM_USER_UNKNOWN, 10, "PAM_USER_UNKNOWN must be 10");
}

/* ============================================================================
 * Test Runner
 * ============================================================================
 */

int main(int argc, char **argv) {
  TEST_INIT(30, false, false);

  /* login.defs parsing */
  RUN_TEST(get_encrypt_method_sha512);
  RUN_TEST(get_encrypt_method_sha256);
  RUN_TEST(get_encrypt_method_yescrypt);
  RUN_TEST(get_encrypt_method_blowfish);
  RUN_TEST(get_encrypt_method_missing);
  RUN_TEST(get_encrypt_method_empty_value);
  RUN_TEST(get_encrypt_method_file_not_found);
  RUN_TEST(get_encrypt_method_with_comments);
  RUN_TEST(get_encrypt_method_with_leading_whitespace);
  RUN_TEST(get_encrypt_method_case_insensitive_key);
  RUN_TEST(get_encrypt_method_null_ops);
  RUN_TEST(get_yescrypt_cost_factor);
  RUN_TEST(get_sha_crypt_rounds);

  /* Salt generation */
  RUN_TEST(generate_salt_sha512_prefix);
  RUN_TEST(generate_salt_sha256_prefix);
  RUN_TEST(generate_salt_yescrypt_prefix);
  RUN_TEST(generate_salt_yescrypt_cost_encoded);
  RUN_TEST(generate_salt_sufficient_length);
  RUN_TEST(generate_salt_getrandom_fails);
  RUN_TEST(generate_salt_null_buffer);
  RUN_TEST(generate_salt_crypt_gensalt_ra_fails);

  /* Password hashing and verification */
  RUN_TEST(hash_password_sha512);
  RUN_TEST(hash_password_sha256);
  RUN_TEST(hash_password_yescrypt);
  RUN_TEST(hash_password_null_password);
  RUN_TEST(hash_password_empty_password);
  RUN_TEST(hash_password_crypt_r_fails);
  RUN_TEST(hash_password_getrandom_fails);
  RUN_TEST(verify_password_correct);
  RUN_TEST(verify_password_incorrect);
  RUN_TEST(verify_password_yescrypt);
  RUN_TEST(verify_password_constant_time);
  RUN_TEST(verify_password_null_inputs);
  RUN_TEST(verify_password_crypt_r_fails);

  /* Password file validation */
  RUN_TEST(validate_passwd_file_good);
  RUN_TEST(validate_passwd_file_world_readable);
  RUN_TEST(validate_passwd_file_group_readable);
  RUN_TEST(validate_passwd_file_wrong_owner);
  RUN_TEST(validate_passwd_file_not_regular);
  RUN_TEST(validate_passwd_file_open_fails);
  RUN_TEST(validate_passwd_file_fstat_fails);

  /* PAM argument parsing */
  RUN_TEST(parse_args_no_args);
  RUN_TEST(parse_args_file_override);
  RUN_TEST(parse_args_nullok);
  RUN_TEST(parse_args_multiple);
  RUN_TEST(parse_args_unknown_arg);

  /* Core authentication */
  RUN_TEST(pam_auth_success);
  RUN_TEST(pam_auth_wrong_password);
  RUN_TEST(pam_auth_no_password_file);
  RUN_TEST(pam_auth_no_password_file_nullok);
  RUN_TEST(pam_auth_null_user);
  RUN_TEST(pam_auth_null_authtok);
  RUN_TEST(pam_auth_user_not_in_passwd);
  RUN_TEST(pam_auth_file_argument);
  RUN_TEST(pam_auth_mlock_failure_continues);
  RUN_TEST(pam_auth_yescrypt_success);

  /* PAM stubs verification */
  RUN_TEST(pam_return_codes_values);

  return TEST_EXECUTE();
}
