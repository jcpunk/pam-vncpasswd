/**
 * pam_vncpasswd.c - PAM module and core authentication logic
 *
 * Implements authentication against a per-user VNC password file
 * (~/.vnc/passwd) using proper crypt(3) hashing.
 *
 * SECURITY MODEL:
 * - crypt_r(3) for thread-safe hashing
 * - crypt_gensalt_ra(3) for secure, algorithm-aware salt generation
 * - O_NOFOLLOW + fstat() for TOCTOU-safe file access
 * - Constant-time XOR comparison to prevent timing attacks
 * - explicit_bzero() on all sensitive buffers
 * - mlock() to prevent password pages from being swapped to disk
 *
 * YESCRYPT SUPPORT:
 * yescrypt is the default on modern RHEL/Fedora. Unlike SHA-crypt,
 * yescrypt uses a cost factor (not a round count) that is encoded by
 * crypt_gensalt_ra() into a parameter string (e.g., "j9T") rather than
 * the "rounds=N$" prefix used by SHA-512/SHA-256. We read
 * YESCRYPT_COST_FACTOR from login.defs (default: DEFAULT_YESCRYPT_COST)
 * and ENCRYPT_METHOD (default: DEFAULT_ENCRYPT_METHOD).
 *
 * PAM ENTRY POINTS:
 * The pam_sm_* functions are thin wrappers around authenticate_vnc_user().
 * This separation keeps the core logic testable without PAM headers.
 */

#include <crypt.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

/* autoconf.h is generated by CMake from autoconf.h.in */
#include "autoconf.h"
#include "pam_vncpasswd.h"
#include "syscall_ops.h"

/*
 * PAM module definition flags — must be set before including PAM headers
 * to tell libpam this is a module (not an application).
 */
#ifdef HAVE_PAM
#define PAM_SM_AUTH
#define PAM_SM_ACCOUNT
#define PAM_SM_SESSION
#define PAM_SM_PASSWORD
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#else
/*
 * Minimal PAM return codes for compilation without PAM headers.
 * These integer values are defined by the PAM standard and must
 * match the real constants. Used by authenticate_vnc_user() so that
 * tests can validate return values without linking against libpam.
 */
#define PAM_SUCCESS         0
#define PAM_AUTH_ERR        7
#define PAM_AUTHINFO_UNAVAIL 9
#define PAM_USER_UNKNOWN    10
#define PAM_AUTHTOK_ERR     20
#endif /* HAVE_PAM */

/* ============================================================================
 * login.defs Parsing
 * ============================================================================
 */

/**
 * parse_login_defs_line - Parse a single login.defs directive
 * @line: Input line (modified in place — whitespace stripped)
 * @key: Directive name to search for (e.g., "ENCRYPT_METHOD")
 * @value_out: Output buffer for the directive value
 * @value_len: Size of value_out
 *
 * Skips comment lines (starting with '#') and blank lines.
 * Key matching is case-sensitive per login.defs convention.
 *
 * Returns: 1 if key was found and value extracted, 0 otherwise
 */
static int parse_login_defs_line(char *line, const char *key,
                                 char *value_out, size_t value_len) {
  char *p = line;
  size_t key_len;

  /* Skip leading whitespace */
  while (*p == ' ' || *p == '\t')
    p++;

  /* Skip comment lines and blank lines */
  if (*p == '#' || *p == '\n' || *p == '\0')
    return 0;

  key_len = strlen(key);
  if (strncmp(p, key, key_len) != 0)
    return 0;

  /* Key must be followed by whitespace */
  p += key_len;
  if (*p != ' ' && *p != '\t')
    return 0;

  /* Skip whitespace between key and value */
  while (*p == ' ' || *p == '\t')
    p++;

  /* Empty value after key — treat as not found */
  if (*p == '\0' || *p == '\n' || *p == '#')
    return 0;

  /* Strip trailing whitespace and newline */
  char *end = p + strlen(p) - 1;
  while (end > p && (*end == '\n' || *end == '\r' || *end == ' ' || *end == '\t'))
    *end-- = '\0';

  if (strlen(p) == 0)
    return 0;

  /* Copy value to output buffer */
  if (snprintf(value_out, value_len, "%s", p) < 0)
    return 0;

  return 1;
}

int get_encrypt_settings(const struct syscall_ops *ops,
                         const char *login_defs_path,
                         struct encrypt_settings *settings) {
  FILE *fp;
  char line[LOGIN_DEFS_LINE_MAX];
  char value[ENCRYPT_METHOD_MAX];
  bool have_method = false;
  bool have_yescrypt_cost = false;
  bool have_sha_rounds = false;

  if (!ops || !login_defs_path || !settings) {
    errno = EINVAL;
    return -1;
  }

  /* Initialize with compiled-in defaults */
  if (snprintf(settings->method, sizeof(settings->method),
               "%s", DEFAULT_ENCRYPT_METHOD) < 0) {
    errno = EINVAL;
    return -1;
  }
  settings->yescrypt_cost = (unsigned long)DEFAULT_YESCRYPT_COST;
  settings->sha_rounds = (unsigned long)DEFAULT_SHA_CRYPT_ROUNDS;

  fp = ops->fopen(login_defs_path, "r");
  if (!fp) {
    /* Missing login.defs is not an error — use defaults */
    return 0;
  }

  while (ops->fgets(line, (int)sizeof(line), fp) != NULL) {
    if (!have_method &&
        parse_login_defs_line(line, "ENCRYPT_METHOD", value, sizeof(value))) {
      if (snprintf(settings->method, sizeof(settings->method),
                   "%s", value) > 0)
        have_method = true;
      continue;
    }

    /*
     * YESCRYPT_COST_FACTOR: controls the cost parameter passed to
     * crypt_gensalt_ra() for yescrypt. This is NOT the same as
     * SHA_CRYPT_MAX_ROUNDS — yescrypt uses a different cost scale.
     * The shadow-utils default is 5 (N=32768).
     */
    if (!have_yescrypt_cost &&
        parse_login_defs_line(line, "YESCRYPT_COST_FACTOR",
                              value, sizeof(value))) {
      char *endptr;
      unsigned long v = strtoul(value, &endptr, 10);
      if (*endptr == '\0' && v > 0) {
        settings->yescrypt_cost = v;
        have_yescrypt_cost = true;
      }
      continue;
    }

    /*
     * SHA_CRYPT_MAX_ROUNDS: controls the "rounds=N" prefix for
     * SHA-256 and SHA-512 salts. Has no effect on yescrypt.
     */
    if (!have_sha_rounds &&
        parse_login_defs_line(line, "SHA_CRYPT_MAX_ROUNDS",
                              value, sizeof(value))) {
      char *endptr;
      unsigned long v = strtoul(value, &endptr, 10);
      if (*endptr == '\0' && v > 0) {
        settings->sha_rounds = v;
        have_sha_rounds = true;
      }
      continue;
    }
  }

  ops->fclose(fp);
  return 0;
}

/* ============================================================================
 * Salt Generation
 * ============================================================================
 */

/**
 * method_to_prefix - Convert ENCRYPT_METHOD name to crypt prefix
 * @method: Method string (e.g., "SHA512", "YESCRYPT")
 * @prefix_out: Output buffer for prefix (e.g., "$6$", "$y$")
 * @prefix_len: Size of prefix_out
 *
 * Returns: 0 on success, -1 if method is unknown
 */
static int method_to_prefix(const char *method, char *prefix_out,
                             size_t prefix_len) {
  static const struct {
    const char *name;
    const char *prefix;
  } methods[] = {
    { "SHA512",   "$6$"  },
    { "SHA256",   "$5$"  },
    { "YESCRYPT", "$y$"  },
    { "MD5",      "$1$"  },
    { "BLOWFISH", "$2b$" },
    { "BCRYPT",   "$2b$" },
    { "DES",      ""     },
    { NULL,       NULL   }
  };

  for (int i = 0; methods[i].name != NULL; i++) {
    if (strcmp(method, methods[i].name) == 0) {
      if (snprintf(prefix_out, prefix_len, "%s", methods[i].prefix) < 0)
        return -1;
      return 0;
    }
  }

  errno = EINVAL;
  return -1;
}

int generate_salt(const struct syscall_ops *ops,
                  const struct encrypt_settings *settings,
                  char *salt_buf, size_t salt_len) {
  char prefix[16];
  unsigned long count;
  char rbytes[32];
  char *salt;

  if (!ops || !settings || !salt_buf || salt_len == 0) {
    errno = EINVAL;
    return -1;
  }

  if (method_to_prefix(settings->method, prefix, sizeof(prefix)) < 0)
    return -1;

  /*
   * Choose the cost parameter for crypt_gensalt_ra:
   * - yescrypt: use YESCRYPT_COST_FACTOR (e.g., 5)
   *   libxcrypt encodes this as the yescrypt "N" parameter internally.
   *   The resulting salt looks like "$y$j9T$<base64>$" (for cost=5).
   * - SHA-256/SHA-512: use SHA_CRYPT_MAX_ROUNDS (e.g., 65536)
   *   crypt_gensalt_ra adds "rounds=65536$" to the salt automatically.
   * - bcrypt: use log2(rounds); 12 is a good default for bcrypt.
   * - MD5/DES: count is ignored (these algorithms have no round tuning).
   *
   * This is the fundamental difference from SHA-crypt: yescrypt count
   * is a cost factor, not a round count, and must NOT be set to 65536.
   */
  if (strcmp(settings->method, "YESCRYPT") == 0) {
    count = settings->yescrypt_cost;
  } else if (strcmp(settings->method, "BLOWFISH") == 0 ||
             strcmp(settings->method, "BCRYPT") == 0) {
    count = 12UL; /* log2(4096) — standard bcrypt default */
  } else {
    count = settings->sha_rounds;
  }

  /* Gather entropy for the salt */
  ssize_t n = ops->getrandom(rbytes, sizeof(rbytes), 0);
  if (n < 0)
    return -1;

  /*
   * crypt_gensalt_ra allocates and returns a heap string.
   * It handles the algorithm-specific encoding:
   * - For SHA-512/SHA-256: adds "rounds=N$" to the salt
   * - For yescrypt: encodes cost as param string (e.g., "$y$j9T$...")
   * - For bcrypt: encodes log2(rounds) in the salt
   */
  salt = ops->crypt_gensalt_ra(prefix, count, rbytes, (int)n);
  if (!salt) {
    errno = EINVAL;
    return -1;
  }

  if (snprintf(salt_buf, salt_len, "%s", salt) < 0) {
    ops->free(salt);
    errno = ERANGE;
    return -1;
  }

  ops->free(salt);
  return 0;
}

/* ============================================================================
 * Password Hashing and Verification
 * ============================================================================
 */

int hash_password(const struct syscall_ops *ops, const char *password,
                  const struct encrypt_settings *settings,
                  char *hash_buf, size_t hash_len) {
  char salt[SALT_BUF_SIZE];
  struct crypt_data cd;
  char *result;

  if (!ops || !password || *password == '\0' || !settings ||
      !hash_buf || hash_len == 0) {
    errno = EINVAL;
    return -1;
  }

  if (generate_salt(ops, settings, salt, sizeof(salt)) < 0)
    return -1;

  memset(&cd, 0, sizeof(cd));
  result = ops->crypt_r(password, salt, &cd);
  if (!result || result[0] == '*') {
    errno = EINVAL;
    explicit_bzero(salt, sizeof(salt));
    explicit_bzero(&cd, sizeof(cd));
    return -1;
  }

  if (snprintf(hash_buf, hash_len, "%s", result) < 0) {
    explicit_bzero(salt, sizeof(salt));
    explicit_bzero(&cd, sizeof(cd));
    errno = ERANGE;
    return -1;
  }

  explicit_bzero(salt, sizeof(salt));
  explicit_bzero(&cd, sizeof(cd));
  return 0;
}

int verify_password(const struct syscall_ops *ops, const char *password,
                    const char *stored_hash) {
  struct crypt_data cd;
  char *computed;
  unsigned char diff;
  size_t i;
  size_t computed_len;
  size_t stored_len;

  if (!ops || !password || !stored_hash) {
    errno = EINVAL;
    return -1;
  }

  memset(&cd, 0, sizeof(cd));
  computed = ops->crypt_r(password, stored_hash, &cd);
  if (!computed || computed[0] == '*') {
    explicit_bzero(&cd, sizeof(cd));
    errno = EINVAL;
    return -1;
  }

  /*
   * Constant-time comparison using XOR accumulator.
   * Avoids early exit that would leak timing information about
   * how many characters of the hash match the expected value.
   *
   * We compare the full length of the longer string so that
   * different-length hashes also take constant time.
   */
  computed_len = strlen(computed);
  stored_len = strlen(stored_hash);
  diff = (unsigned char)(computed_len != stored_len);

  for (i = 0; i < computed_len && i < stored_len; i++) {
    diff |= (unsigned char)computed[i] ^ (unsigned char)stored_hash[i];
  }

  explicit_bzero(&cd, sizeof(cd));
  return (diff == 0) ? 0 : -1;
}

/* ============================================================================
 * Password File Operations
 * ============================================================================
 */

int validate_passwd_file(const struct syscall_ops *ops, const char *path,
                         uid_t expected_uid) {
  int fd;
  struct stat st;

  if (!ops || !path) {
    errno = EINVAL;
    return -1;
  }

  /*
   * Open with O_NOFOLLOW to prevent symlink attacks (TOCTOU).
   * If the path is a symlink, open() returns ELOOP.
   */
  fd = ops->open(path, O_RDONLY | O_NOFOLLOW);
  if (fd < 0)
    return -1;

  if (ops->fstat(fd, &st) < 0) {
    ops->close(fd);
    return -1;
  }

  /* Verify file is a regular file (not a symlink or special file) */
  if (!S_ISREG(st.st_mode)) {
    ops->close(fd);
    errno = EACCES;
    return -1;
  }

  /* Verify ownership */
  if (st.st_uid != expected_uid) {
    ops->close(fd);
    errno = EACCES;
    return -1;
  }

  /*
   * Verify permissions: must be 0600 or stricter.
   * Group-readable (0640) or world-readable (0644) files are rejected
   * because they could allow other users to read the hash and perform
   * offline dictionary attacks.
   */
  if (st.st_mode & (S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) {
    ops->close(fd);
    errno = EACCES;
    return -1;
  }

  return fd;
}

int read_passwd_hash(const struct syscall_ops *ops, int fd,
                     char *hash_buf, size_t hash_len) {
  FILE *fp;
  char *p;

  if (!ops || fd < 0 || !hash_buf || hash_len == 0) {
    if (fd >= 0)
      ops->close(fd);
    errno = EINVAL;
    return -1;
  }

  fp = ops->fopen("/dev/fd/0", "r");
  /*
   * We can't use fopen on the fd directly in a portable way;
   * use fdopen-style by wrapping. Since ops->fopen takes a path,
   * we use a workaround: create an fdopen-compatible path or
   * read the file ourselves using the fd.
   *
   * For simplicity, use read() directly to read a line from the fd.
   */
  (void)fp; /* Not used — see below */

  /* Read the hash line directly from the fd */
  ssize_t nread = 0;
  size_t pos = 0;
  char c;

  while (pos < hash_len - 1) {
    nread = read(fd, &c, 1);
    if (nread <= 0)
      break;
    if (c == '\n')
      break;
    hash_buf[pos++] = c;
  }
  hash_buf[pos] = '\0';
  ops->close(fd);

  if (pos == 0) {
    errno = ENODATA;
    return -1;
  }

  /* Strip trailing whitespace */
  p = hash_buf + strlen(hash_buf) - 1;
  while (p >= hash_buf && (*p == '\r' || *p == '\n' || *p == ' '))
    *p-- = '\0';

  return 0;
}

/* ============================================================================
 * PAM Argument Parsing
 * ============================================================================
 */

void parse_pam_args(int argc, const char **argv, struct pam_args *args) {
  if (!args)
    return;

  args->file = NULL;
  args->nullok = false;

  for (int i = 0; i < argc; i++) {
    if (!argv[i])
      continue;
    if (strncmp(argv[i], "file=", 5) == 0) {
      args->file = argv[i] + 5;
    } else if (strcmp(argv[i], "nullok") == 0) {
      args->nullok = true;
    }
    /* Unknown args are silently ignored for forward compatibility */
  }
}

/* ============================================================================
 * Core Authentication Logic
 * ============================================================================
 */

int authenticate_vnc_user(const struct syscall_ops *ops, const char *username,
                          const char *password, const char *file_override,
                          bool nullok) {
  struct passwd pw;
  struct passwd *pwresult;
  char pwbuf[4096];
  char passwd_path[PAM_ARGS_FILE_MAX];
  char hash[HASH_BUF_SIZE];
  int fd;
  int ret;
  bool mlocked = false;

  if (!ops || !username || !password)
    return PAM_AUTH_ERR;

  /*
   * Lock the password in RAM to prevent it being swapped to disk.
   * mlock failure is non-fatal — we continue authentication.
   */
  if (ops->mlock(password, strlen(password) + 1) == 0)
    mlocked = true;

  /* Determine the password file path */
  if (file_override) {
    if (snprintf(passwd_path, sizeof(passwd_path),
                 "%s", file_override) < 0) {
      ret = PAM_AUTH_ERR;
      goto out;
    }
  } else {
    /* Look up user's home directory */
    if (ops->getpwnam_r(username, &pw, pwbuf, sizeof(pwbuf), &pwresult) != 0
        || pwresult == NULL) {
      ret = PAM_USER_UNKNOWN;
      goto out;
    }

    if (!pw.pw_dir || pw.pw_dir[0] == '\0') {
      ret = PAM_USER_UNKNOWN;
      goto out;
    }

    if (snprintf(passwd_path, sizeof(passwd_path), "%s/%s/%s",
                 pw.pw_dir, VNC_PASSWD_DIR, VNC_PASSWD_FILE) < 0) {
      ret = PAM_AUTH_ERR;
      goto out;
    }

    /* Validate file ownership using the user's UID */
    fd = validate_passwd_file(ops, passwd_path, pw.pw_uid);
  }

  if (file_override) {
    /*
     * When using a file override, we don't know the expected UID.
     * Use 0 to skip ownership check (root-managed override files).
     * In practice, the sysadmin is responsible for securing the file.
     */
    fd = ops->open(passwd_path, O_RDONLY | O_NOFOLLOW);
    if (fd < 0) {
      ret = nullok ? PAM_SUCCESS : PAM_AUTHINFO_UNAVAIL;
      goto out;
    }
  } else {
    fd = validate_passwd_file(ops, passwd_path, pw.pw_uid);
    if (fd < 0) {
      if (errno == ENOENT) {
        ret = nullok ? PAM_SUCCESS : PAM_AUTHINFO_UNAVAIL;
      } else {
        ret = PAM_AUTH_ERR;
      }
      goto out;
    }
  }

  /* Read the stored hash from the file */
  if (read_passwd_hash(ops, fd, hash, sizeof(hash)) < 0) {
    ret = PAM_AUTHINFO_UNAVAIL;
    goto out_wipe;
  }

  /* Verify the password */
  if (verify_password(ops, password, hash) == 0) {
    ret = PAM_SUCCESS;
  } else {
    ret = PAM_AUTH_ERR;
  }

out_wipe:
  explicit_bzero(hash, sizeof(hash));
out:
  if (mlocked)
    ops->munlock(password, strlen(password) + 1);
  return ret;
}

/* ============================================================================
 * Directory Management
 * ============================================================================
 */

int ensure_vnc_dir(const struct syscall_ops *ops, const char *path) {
  struct stat st;

  if (!ops || !path) {
    errno = EINVAL;
    return -1;
  }

  /* Use lstat to detect existing entries (including symlinks) */
  if (ops->lstat(path, &st) == 0) {
    if (!S_ISDIR(st.st_mode)) {
      errno = ENOTDIR;
      return -1;
    }
    /* Directory already exists — success */
    return 0;
  }

  if (errno != ENOENT)
    return -1;

  /* Create with 0700: only owner can read/write/exec */
  if (ops->mkdir(path, 0700) < 0)
    return -1;

  return 0;
}

int atomic_write_passwd(const struct syscall_ops *ops, const char *path,
                        const char *hash) {
  char tmp_path[PAM_ARGS_FILE_MAX];
  int fd;
  ssize_t written;
  size_t hash_len;

  if (!ops || !path || !hash) {
    errno = EINVAL;
    return -1;
  }

  /*
   * Build a temp path in the same directory so rename() is atomic.
   * mkstemp() requires the last 6 chars to be "XXXXXX".
   */
  if (snprintf(tmp_path, sizeof(tmp_path), "%s.XXXXXX", path) < 0) {
    errno = ERANGE;
    return -1;
  }

  fd = ops->mkstemp(tmp_path);
  if (fd < 0)
    return -1;

  /* Set permissions before writing any data */
  if (ops->fchmod(fd, 0600) < 0)
    goto fail;

  /* Write hash + newline */
  hash_len = strlen(hash);
  written = write(fd, hash, hash_len);
  if (written < 0 || (size_t)written != hash_len)
    goto fail;
  written = write(fd, "\n", 1);
  if (written != 1)
    goto fail;

  /* Flush to disk before rename */
  if (ops->fsync(fd) < 0)
    goto fail;

  ops->close(fd);

  /* Atomically replace the destination */
  if (ops->rename(tmp_path, path) < 0) {
    ops->unlink(tmp_path);
    return -1;
  }

  return 0;

fail:
  {
    int saved = errno;
    ops->close(fd);
    ops->unlink(tmp_path);
    errno = saved;
    return -1;
  }
}

/* ============================================================================
 * PAM Entry Points (thin wrappers, require HAVE_PAM)
 * ============================================================================
 */

#ifdef HAVE_PAM

PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags,
                                   int argc, const char **argv) {
  const char *username = NULL;
  const char *authtok = NULL;
  struct pam_args args;

  (void)flags;

  parse_pam_args(argc, argv, &args);

  if (pam_get_user(pamh, &username, NULL) != PAM_SUCCESS || !username)
    return PAM_AUTH_ERR;

  if (pam_get_authtok(pamh, PAM_AUTHTOK, &authtok, NULL) != PAM_SUCCESS
      || !authtok)
    return PAM_AUTHTOK_ERR;

  return authenticate_vnc_user(&syscall_ops_default, username, authtok,
                               args.file, args.nullok);
}

PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags,
                              int argc, const char **argv) {
  (void)pamh; (void)flags; (void)argc; (void)argv;
  return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,
                                 int argc, const char **argv) {
  (void)pamh; (void)flags; (void)argc; (void)argv;
  return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
                                   int argc, const char **argv) {
  (void)pamh; (void)flags; (void)argc; (void)argv;
  return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags,
                                    int argc, const char **argv) {
  (void)pamh; (void)flags; (void)argc; (void)argv;
  return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags,
                                 int argc, const char **argv) {
  (void)pamh; (void)flags; (void)argc; (void)argv;
  return PAM_SUCCESS;
}

#endif /* HAVE_PAM */
