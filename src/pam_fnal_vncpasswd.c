/**
 * pam_fnal_vncpasswd.c - PAM module core and authentication logic
 *
 * Implements authentication against a per-user VNC password file
 * (~/.config/vnc/fnal_vncpasswd by default) using proper crypt(3) hashing.
 *
 * SECURITY MODEL:
 * - crypt_r(3) for thread-safe hashing
 * - crypt_gensalt_ra(3) for secure, algorithm-aware salt generation
 * - O_NOFOLLOW + fstat() for TOCTOU-safe file access
 * - Constant-time XOR comparison to prevent timing attacks
 * - explicit_bzero() on all sensitive buffers
 * - mlock() to prevent password pages from being swapped to disk
 *
 * YESCRYPT SUPPORT:
 * yescrypt is the default on modern RHEL/Fedora. Unlike SHA-crypt,
 * yescrypt uses a cost factor (not a round count) that is encoded by
 * crypt_gensalt_ra() into a parameter string (e.g., "j9T") rather than
 * the "rounds=N$" prefix used by SHA-512/SHA-256. We read
 * YESCRYPT_COST_FACTOR from login.defs (default: DEFAULT_YESCRYPT_COST)
 * and ENCRYPT_METHOD (default: DEFAULT_ENCRYPT_METHOD).
 *
 * PAM ENTRY POINTS:
 * The pam_sm_* functions live in pam_entry.c, which is compiled only into
 * pam_fnal_vncpasswd.so (and not into test binaries). This file contains
 * only the testable core logic.
 */

#include <crypt.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#ifdef HAVE_SELINUX
#include <selinux/selinux.h>
#endif

/* autoconf.h is generated by CMake from autoconf.h.in */
#include "autoconf.h"
#include "pam_fnal_vncpasswd.h"
#include "syscall_ops.h"

/*
 * Minimal PAM return codes used by authenticate_vnc_user().
 * These match the integer values defined by the PAM standard.
 * pam_entry.c (which includes the real PAM headers) uses the real constants.
 */
#define PAM_SUCCESS          0
#define PAM_AUTH_ERR         7
#define PAM_AUTHINFO_UNAVAIL 9
#define PAM_USER_UNKNOWN     10

/* ============================================================================
 * login.defs Parsing
 * ============================================================================
 */

/**
 * parse_login_defs_line - Parse a single login.defs directive
 * @line: Input line (modified in place)
 * @key: Directive name to search for
 * @value_out: Output buffer for the directive value
 * @value_len: Size of value_out
 *
 * Returns: 1 if key was found and value extracted, 0 otherwise
 */
static int parse_login_defs_line(char *line, const char *key,
                                 char *value_out, size_t value_len) {
  char *p;
  size_t key_len;

  if (!line || !key || !value_out || value_len == 0)
    return 0;

  p = line;

  /* Skip leading whitespace */
  while (*p == ' ' || *p == '\t')
    p++;

  /* Skip comment lines and blank lines */
  if (*p == '#' || *p == '\n' || *p == '\0')
    return 0;

  key_len = strlen(key);
  if (strncmp(p, key, key_len) != 0)
    return 0;

  /* Key must be followed by whitespace */
  p += key_len;
  if (*p != ' ' && *p != '\t')
    return 0;

  /* Skip whitespace between key and value */
  while (*p == ' ' || *p == '\t')
    p++;

  /* Empty value after key — treat as not found */
  if (*p == '\0' || *p == '\n' || *p == '#')
    return 0;

  /* Strip trailing whitespace and newline */
  char *end = p + strlen(p) - 1;
  while (end > p && (*end == '\n' || *end == '\r' || *end == ' ' || *end == '\t'))
    *end-- = '\0';

  if (strlen(p) == 0)
    return 0;

  {
    int _snret = snprintf(value_out, value_len, "%s", p);
    if (_snret < 0 || (size_t)_snret >= value_len)
      return 0;
  }

  return 1;
}

int get_encrypt_settings(const struct syscall_ops *ops,
                         const char *login_defs_path,
                         struct encrypt_settings *settings) {
  FILE *fp;
  char line[LOGIN_DEFS_LINE_MAX];
  char value[ENCRYPT_METHOD_MAX];
  bool have_method = false;
  bool have_yescrypt_cost = false;
  bool have_sha_rounds = false;

  if (!ops || !login_defs_path || !settings) {
    errno = EINVAL;
    return -1;
  }

  /* Initialize with compiled-in defaults */
  {
    int _snret = snprintf(settings->method, sizeof(settings->method),
                          "%s", DEFAULT_ENCRYPT_METHOD);
    if (_snret < 0 || (size_t)_snret >= sizeof(settings->method)) {
      errno = EINVAL;
      return -1;
    }
  }
  settings->yescrypt_cost = (unsigned long)DEFAULT_YESCRYPT_COST;
  settings->sha_rounds = (unsigned long)DEFAULT_SHA_CRYPT_ROUNDS;

  fp = ops->fopen(login_defs_path, "r");
  if (!fp) {
    /* Missing login.defs is not an error — use defaults */
    return 0;
  }

  while (ops->fgets(line, (int)sizeof(line), fp) != NULL) {
    if (!have_method &&
        parse_login_defs_line(line, "ENCRYPT_METHOD", value, sizeof(value))) {
      {
        int _snret = snprintf(settings->method, sizeof(settings->method),
                              "%s", value);
        if (_snret > 0 && (size_t)_snret < sizeof(settings->method))
          have_method = true;
      }
      continue;
    }

    /*
     * YESCRYPT_COST_FACTOR: controls the cost parameter passed to
     * crypt_gensalt_ra() for yescrypt. This is NOT the same as
     * SHA_CRYPT_MAX_ROUNDS — yescrypt uses a different cost scale.
     */
    if (!have_yescrypt_cost &&
        parse_login_defs_line(line, "YESCRYPT_COST_FACTOR",
                              value, sizeof(value))) {
      char *endptr;
      unsigned long v = strtoul(value, &endptr, 10);
      if (*endptr == '\0' && v > 0) {
        settings->yescrypt_cost = v;
        have_yescrypt_cost = true;
      }
      continue;
    }

    /*
     * SHA_CRYPT_MAX_ROUNDS: controls the "rounds=N" prefix for
     * SHA-256 and SHA-512 salts. Has no effect on yescrypt.
     */
    if (!have_sha_rounds &&
        parse_login_defs_line(line, "SHA_CRYPT_MAX_ROUNDS",
                              value, sizeof(value))) {
      char *endptr;
      unsigned long v = strtoul(value, &endptr, 10);
      if (*endptr == '\0' && v > 0) {
        settings->sha_rounds = v;
        have_sha_rounds = true;
      }
      continue;
    }
  }

  ops->fclose(fp);
  return 0;
}

/* ============================================================================
 * Salt Generation
 * ============================================================================
 */

/**
 * method_to_prefix - Convert ENCRYPT_METHOD name to crypt prefix
 */
static int method_to_prefix(const char *method, char *prefix_out,
                             size_t prefix_len) {
  static const struct {
    const char *name;
    const char *prefix;
  } methods[] = {
    { "SHA512",   "$6$"  },
    { "SHA256",   "$5$"  },
    { "YESCRYPT", "$y$"  },
    { "MD5",      "$1$"  },
    { "BLOWFISH", "$2b$" },
    { "BCRYPT",   "$2b$" },
    { "DES",      ""     },
    { NULL,       NULL   }
  };

  for (int i = 0; methods[i].name != NULL; i++) {
    if (strcmp(method, methods[i].name) == 0) {
      int _snret = snprintf(prefix_out, prefix_len, "%s", methods[i].prefix);
      if (_snret < 0 || (size_t)_snret >= prefix_len)
        return -1;
      return 0;
    }
  }

  errno = EINVAL;
  return -1;
}

int generate_salt(const struct syscall_ops *ops,
                  const struct encrypt_settings *settings,
                  char *salt_buf, size_t salt_len) {
  char prefix[16];
  unsigned long count;
  char rbytes[32];
  char *salt;

  if (!ops || !settings || !salt_buf || salt_len == 0) {
    errno = EINVAL;
    return -1;
  }

  if (method_to_prefix(settings->method, prefix, sizeof(prefix)) < 0)
    return -1;

  /*
   * Choose the cost parameter for crypt_gensalt_ra:
   * - yescrypt: use YESCRYPT_COST_FACTOR (e.g., 5)
   *   libxcrypt encodes this as yescrypt parameters internally.
   *   The resulting salt looks like "$y$j9T$<base64>$" (for cost=5).
   * - SHA-256/SHA-512: use SHA_CRYPT_MAX_ROUNDS (e.g., 65536)
   *   crypt_gensalt_ra adds "rounds=65536$" to the salt automatically.
   * - bcrypt: use log2(rounds); 12 is a good default.
   * - MD5/DES: count is ignored.
   */
  if (strcmp(settings->method, "YESCRYPT") == 0) {
    count = settings->yescrypt_cost;
  } else if (strcmp(settings->method, "BLOWFISH") == 0 ||
             strcmp(settings->method, "BCRYPT") == 0) {
    count = 12UL;
  } else {
    count = settings->sha_rounds;
  }

  ssize_t n = ops->getrandom(rbytes, sizeof(rbytes), 0);
  if (n < 0)
    return -1;

  salt = ops->crypt_gensalt_ra(prefix, count, rbytes, (int)n);
  if (!salt) {
    errno = EINVAL;
    return -1;
  }

  {
    int _snret = snprintf(salt_buf, salt_len, "%s", salt);
    if (_snret < 0 || (size_t)_snret >= salt_len) {
      ops->free(salt);
      errno = ERANGE;
      return -1;
    }
  }

  ops->free(salt);
  return 0;
}

/* ============================================================================
 * Password Hashing and Verification
 * ============================================================================
 */

int hash_password(const struct syscall_ops *ops, const char *password,
                  const struct encrypt_settings *settings,
                  char *hash_buf, size_t hash_len) {
  char salt[SALT_BUF_SIZE];
  struct crypt_data cd;
  char *result;

  if (!ops || !password || *password == '\0' || !settings ||
      !hash_buf || hash_len == 0) {
    errno = EINVAL;
    return -1;
  }

  if (generate_salt(ops, settings, salt, sizeof(salt)) < 0)
    return -1;

  memset(&cd, 0, sizeof(cd));
  result = ops->crypt_r(password, salt, &cd);
  if (!result || result[0] == '*') {
    errno = EINVAL;
    explicit_bzero(salt, sizeof(salt));
    explicit_bzero(&cd, sizeof(cd));
    return -1;
  }

  {
    int _snret = snprintf(hash_buf, hash_len, "%s", result);
    if (_snret < 0 || (size_t)_snret >= hash_len) {
      explicit_bzero(salt, sizeof(salt));
      explicit_bzero(&cd, sizeof(cd));
      errno = ERANGE;
      return -1;
    }
  }

  explicit_bzero(salt, sizeof(salt));
  explicit_bzero(&cd, sizeof(cd));
  return 0;
}

int verify_password(const struct syscall_ops *ops, const char *password,
                    const char *stored_hash) {
  struct crypt_data cd;
  char *computed;
  unsigned char diff;
  size_t i;
  size_t computed_len;
  size_t stored_len;

  if (!ops || !password || !stored_hash) {
    errno = EINVAL;
    return -1;
  }

  memset(&cd, 0, sizeof(cd));
  computed = ops->crypt_r(password, stored_hash, &cd);
  if (!computed || computed[0] == '*') {
    explicit_bzero(&cd, sizeof(cd));
    errno = EINVAL;
    return -1;
  }

  /*
   * Constant-time comparison using XOR accumulator.
   *
   * We iterate to max(computed_len, stored_len) rather than the minimum,
   * using zero as a "padding" byte for the shorter string. This ensures
   * the loop runs for a fixed number of iterations regardless of how many
   * characters match, preventing a length-based timing side-channel.
   *
   * Without this fix, iterating only to min() would leak which of the two
   * strings is shorter (i.e., whether the supplied password produced a
   * hash of the same length as the stored one), giving an attacker partial
   * information about the stored hash format or algorithm.
   */
  computed_len = strlen(computed);
  stored_len = strlen(stored_hash);
  diff = (unsigned char)(computed_len != stored_len);

  {
    size_t max_len = computed_len > stored_len ? computed_len : stored_len;
    for (i = 0; i < max_len; i++) {
      unsigned char c = (i < computed_len) ? (unsigned char)computed[i] : 0;
      unsigned char s = (i < stored_len) ? (unsigned char)stored_hash[i] : 0;
      diff |= c ^ s;
    }
  }

  explicit_bzero(&cd, sizeof(cd));
  return (diff == 0) ? 0 : -1;
}

/* ============================================================================
 * Password File Operations
 * ============================================================================
 */

int validate_passwd_file(const struct syscall_ops *ops, const char *path,
                         uid_t expected_uid) {
  int fd;
  struct stat st;

  if (!ops || !path) {
    errno = EINVAL;
    return -1;
  }

  /* O_NOFOLLOW prevents symlink attacks (TOCTOU) */
  fd = ops->open(path, O_RDONLY | O_NOFOLLOW);
  if (fd < 0)
    return -1;

  if (ops->fstat(fd, &st) < 0) {
    ops->close(fd);
    return -1;
  }

  if (!S_ISREG(st.st_mode)) {
    ops->close(fd);
    errno = EACCES;
    return -1;
  }

  if (st.st_uid != expected_uid) {
    ops->close(fd);
    errno = EACCES;
    return -1;
  }

  /* Reject group- or world-readable files */
  if (st.st_mode & (S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) {
    ops->close(fd);
    errno = EACCES;
    return -1;
  }

  return fd;
}

int read_passwd_hash(const struct syscall_ops *ops, int fd,
                     char *hash_buf, size_t hash_len) {
  FILE *fp;
  char *result;
  char *p;

  if (!ops || fd < 0 || !hash_buf || hash_len == 0) {
    /*
     * Close fd even when ops is NULL to avoid leaking the descriptor.
     * When ops is unavailable we fall back to the bare close(2) syscall
     * because we own the fd regardless of which abstraction layer is used.
     */
    if (fd >= 0) {
      if (ops)
        ops->close(fd);
      else
        close(fd);
    }
    errno = EINVAL;
    return -1;
  }

  /*
   * Wrap the security-validated fd in a buffered FILE* so we can use
   * ops->fgets() — the same abstraction used to read /etc/login.defs.
   * This is preferable to a single-byte ops->read() loop because:
   *   - ops->fgets is already abstracted and exercised by login.defs tests
   *   - Consistent with how the rest of the codebase reads text files
   *   - Tests inject content via setup_fgets_mock() with no real fd needed
   *
   * OWNERSHIP: fdopen(3) takes ownership of fd. Do NOT call ops->close(fd)
   * after a successful fdopen; ops->fclose() will close the underlying fd
   * as part of stream teardown.
   *
   * On fdopen failure the C library does NOT close fd, so we must.
   */
  fp = ops->fdopen(fd, "r");
  if (!fp) {
    ops->close(fd);
    return -1;
  }

  /* Read the single line containing the stored hash */
  result = ops->fgets(hash_buf, (int)hash_len, fp);
  ops->fclose(fp); /* also closes the underlying fd */

  if (!result) {
    errno = ENODATA;
    return -1;
  }

  /* Strip trailing whitespace and newline */
  p = hash_buf + strlen(hash_buf) - 1;
  while (p >= hash_buf && (*p == '\r' || *p == '\n' || *p == ' '))
    *p-- = '\0';

  if (*hash_buf == '\0') {
    errno = ENODATA;
    return -1;
  }

  return 0;
}

/* ============================================================================
 * PAM Argument Parsing
 * ============================================================================
 */

void parse_pam_args(int argc, const char **argv, struct pam_args *args) {
  if (!args)
    return;

  args->file = NULL;
  args->nullok = false;

  for (int i = 0; i < argc; i++) {
    if (!argv[i])
      continue;
    if (strncmp(argv[i], "file=", 5) == 0) {
      args->file = argv[i] + 5;
    } else if (strcmp(argv[i], "nullok") == 0) {
      args->nullok = true;
    }
    /* Unknown args are silently ignored for forward compatibility */
  }
}

/* ============================================================================
 * Core Authentication Logic
 * ============================================================================
 */

int authenticate_vnc_user(const struct syscall_ops *ops, const char *username,
                          const char *password, const char *file_override,
                          bool nullok) {
  struct passwd pw;
  struct passwd *pwresult;
  char pwbuf[4096];
  char passwd_path[PAM_ARGS_FILE_MAX];
  char hash[HASH_BUF_SIZE];
  int fd;
  int ret;
  bool mlocked = false;

  if (!ops || !username || !password)
    return PAM_AUTH_ERR;

  /*
   * No password length check here — a password that is too long to have
   * been set by fnal-vncpasswd (> MAX_PASSWORD_LENGTH) is simply treated
   * as a wrong password. crypt_r() will produce a different hash, and
   * verify_password() will return -1, yielding PAM_AUTH_ERR.
   * This keeps the authentication path free of policy decisions that
   * belong in the password-setting tool.
   */

  /* Lock the password in RAM; mlock failure is non-fatal */
  if (ops->mlock(password, strlen(password) + 1) == 0)
    mlocked = true;

  if (file_override) {
    {
      int _snret = snprintf(passwd_path, sizeof(passwd_path),
                            "%s", file_override);
      if (_snret < 0 || (size_t)_snret >= sizeof(passwd_path)) {
        ret = PAM_AUTH_ERR;
        goto out;
      }
    }
    fd = ops->open(passwd_path, O_RDONLY | O_NOFOLLOW);
    if (fd < 0) {
      ret = (errno == ENOENT && nullok) ? PAM_SUCCESS : PAM_AUTHINFO_UNAVAIL;
      goto out;
    }
  } else {
    if (ops->getpwnam_r(username, &pw, pwbuf, sizeof(pwbuf), &pwresult) != 0
        || pwresult == NULL) {
      /*
       * USER ENUMERATION NOTE:
       * We intentionally return PAM_USER_UNKNOWN (not PAM_AUTH_ERR) for
       * users absent from the system password database. This is standard
       * PAM module behaviour (cf. pam_unix) and lets PAM stacks use
       * pam_succeed_if/pam_listfile to gate access early. An attacker
       * who can enumerate system users via other means (e.g., getent,
       * LDAP, SSH banners) gains no additional information from this
       * return code. If concealment is required, wrap the auth stack with
       * a pam_faildelay and set 'nullok' so that missing-file paths also
       * collapse into a uniform delay before responding.
       */
      ret = PAM_USER_UNKNOWN;
      goto out;
    }

    if (!pw.pw_dir || pw.pw_dir[0] == '\0') {
      ret = PAM_USER_UNKNOWN;
      goto out;
    }

    {
      int _snret = snprintf(passwd_path, sizeof(passwd_path), "%s/%s/%s",
                            pw.pw_dir, VNC_PASSWD_DIR, VNC_PASSWD_FILE);
      if (_snret < 0 || (size_t)_snret >= sizeof(passwd_path)) {
        ret = PAM_AUTH_ERR;
        goto out;
      }
    }

    fd = validate_passwd_file(ops, passwd_path, pw.pw_uid);
    if (fd < 0) {
      ret = (errno == ENOENT && nullok) ? PAM_SUCCESS : PAM_AUTHINFO_UNAVAIL;
      goto out;
    }
  }

  if (read_passwd_hash(ops, fd, hash, sizeof(hash)) < 0) {
    ret = PAM_AUTHINFO_UNAVAIL;
    goto out_wipe;
  }

  ret = (verify_password(ops, password, hash) == 0) ? PAM_SUCCESS : PAM_AUTH_ERR;

out_wipe:
  explicit_bzero(hash, sizeof(hash));
out:
  if (mlocked)
    ops->munlock(password, strlen(password) + 1);
  return ret;
}

/* ============================================================================
 * Directory Management
 * ============================================================================
 */

int ensure_dir(const struct syscall_ops *ops, const char *path) {
  struct stat st;
  char tmp[PAM_ARGS_FILE_MAX];
  char *p;

  if (!ops || !path || path[0] == '\0') {
    errno = EINVAL;
    return -1;
  }

  /*
   * Reject paths that contain directory traversal sequences ("..").
   * We build passwd paths from pw_dir (from the system password database)
   * and VNC_PASSWD_DIR (a build-time constant), neither of which should
   * contain ".." in normal operation. Rejecting them here is a defence-in-
   * depth measure against misconfigured or adversarially crafted inputs.
   */
  {
    size_t plen = strlen(path);
    if (strstr(path, "/../") != NULL ||
        strncmp(path, "../", 3) == 0 ||
        (plen >= 3 && strcmp(path + plen - 3, "/..") == 0) ||
        strcmp(path, "..") == 0) {
      errno = EINVAL;
      return -1;
    }
  }

  /*
   * Walk each path component and create it if missing.
   * This handles multi-segment VNC_PASSWD_DIR values like ".config/vnc"
   * without requiring the parent (~/.config) to already exist.
   */
  {
    int _snret = snprintf(tmp, sizeof(tmp), "%s", path);
    if (_snret < 0 || (size_t)_snret >= sizeof(tmp)) {
      errno = ERANGE;
      return -1;
    }
  }

  for (p = tmp + 1; *p != '\0'; p++) {
    if (*p != '/')
      continue;

    /* Temporarily terminate the string at this slash */
    *p = '\0';

    if (ops->lstat(tmp, &st) == 0) {
      if (!S_ISDIR(st.st_mode)) {
        errno = ENOTDIR;
        return -1;
      }
    } else if (errno == ENOENT) {
      if (ops->mkdir(tmp, 0700) < 0)
        return -1;
    } else {
      return -1;
    }

    *p = '/';
  }

  /* Create (or verify) the final component */
  if (ops->lstat(tmp, &st) == 0) {
    if (!S_ISDIR(st.st_mode)) {
      errno = ENOTDIR;
      return -1;
    }
    return 0;
  }

  if (errno != ENOENT)
    return -1;

  if (ops->mkdir(tmp, 0700) < 0)
    return -1;

  return 0;
}

int atomic_write_passwd(const struct syscall_ops *ops, const char *path,
                        const char *hash) {
  char tmp_path[PAM_ARGS_FILE_MAX];
  int fd;
  ssize_t written;
  size_t hash_len;

  if (!ops || !path || !hash) {
    errno = EINVAL;
    return -1;
  }

  {
    int _snret = snprintf(tmp_path, sizeof(tmp_path), "%s.XXXXXX", path);
    if (_snret < 0 || (size_t)_snret >= sizeof(tmp_path)) {
      errno = ERANGE;
      return -1;
    }
  }

  fd = ops->mkstemp(tmp_path);
  if (fd < 0)
    return -1;

  /* Set permissions before writing any data */
  if (ops->fchmod(fd, 0600) < 0)
    goto fail;

  hash_len = strlen(hash);
  written = ops->write(fd, hash, hash_len);
  if (written < 0 || (size_t)written != hash_len)
    goto fail;
  written = ops->write(fd, "\n", 1);
  if (written != 1)
    goto fail;

  if (ops->fsync(fd) < 0)
    goto fail;

  ops->close(fd);

  /*
   * rename(2) is SELinux-safe here because the temp file was created in
   * the same directory as the destination (path.XXXXXX alongside path).
   * Files created in a directory inherit its SELinux default type
   * transition, so the temp file already carries the correct label.
   * rename(2) never changes SELinux labels — it only moves the name.
   *
   * selinux_restorecon(3) is called when available as a defence against
   * the edge case where the parent directory was itself created with the
   * wrong SELinux context (e.g. by a script that missed the type
   * transition).  It is a no-op when policy already agrees.
   */
  if (ops->rename(tmp_path, path) < 0) {
    ops->unlink(tmp_path);
    return -1;
  }

#ifdef HAVE_SELINUX
  /* Non-fatal: wrong label is bad but must not prevent the password write. */
  (void)selinux_restorecon(path, 0);
#endif

  return 0;

fail:
  {
    int saved = errno;
    ops->close(fd);
    ops->unlink(tmp_path);
    errno = saved;
    return -1;
  }
}
